<!DOCTYPE html>
<html>
    <head>
        <title>Artificial Intelligence</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width = device-width, initial-scale = 1.0">
        <style>
            *
            {
                font-family: monospace;
            }
            h1, h2
            {
                text-align: center;
                text-decoration: underline;
            }
            tr, td, th, table
            {
                border-collapse: collapse;
                text-align: center;
                padding: 0.7%;
                border: 1.5px solid;
            }
            th
            {
                font-size: 110%;
            }
            table
            {
                margin: 0 auto;
            }
            blockquote
            {
                color: #777;
            }
            .underline
            {
                text-decoration: underline;
            }
            .state_box tr td
            {
                padding: 0.25em 0.5em 0.25em 0.5em;
            }
            .production_rules table, .production_rules tr, .production_rules td
            {
                border-style: none !important;
            }
            .text_center
            {
                margin: 0 auto;
                text-align: center;
            }
            .part_not_understood
            {
                color: red;
                text-align: center;
            }
            .additional_reference
            {
                color: orange;
                text-align: center;
            }
        </style>
    </head>
    <body>
        <h1>Artificial Intelligence</h1>
        <hr><hr>
        <strong>Contents</strong>
        <ol>
        	<li><a href="#Module1">Module 1</a></li>
        	<li><a href="#Module2">Module 2</a></li>
        	<li><a href="#Module3">Module 3</a></li>
        	<li><a href="#Module4">Module 4</a></li>
        	<li><a href="#Module5">Module 5</a></li>
        </ol>
        <br>
        <h2 id="Module1">Module 1: Scope of AI & Problem Solving</h2>
        <br>
        <h2>Part 1: Scope of AI</h2>
        <br>
        <h3>Aim of Artificial Intelligence (A.I.)</h3>
        <p>To design an automated system (machine) that has the abillity to think and solve a problem without human intervention.</p>
        <h3>Definition of AI</h3>
        <ol>
            <li>AI is the branch of computer science concerned with designing intelligent computer systems that exhibit intelligent behaviour like humans.</li>
            <li>It deals with symbolic, non-algorithmic methods of problem-solving.</li>
            <li>It is the study of how to make computers do things which at the moment humans do better.</li>
        </ol>
        <h3>4 Dimensions of AI</h3>
        <ol>
            <li>
                <span class="underline">Systems that think like a human (thinking humanly)</span>: To make a program that thinks like a human, one should know how humans think. This can be visualised using:
                <ol>
                    <li><span class="underline">Introspection</span>: Trying to analyse one's own thoughts.</li>
                    <li><span class="underline">Cognitive Science</span>: Bringing together models from AI and Psychology and trying to create precise theories on the working of human mind.</li>
                </ol>
            </li>
            <li>
                <span class="underline">Systems that act like a human (acting humanly)</span>: Alan Turing suggested that human intelligence is unique in it's own way because humans possess the following capabilities:
                <ol>
                    <li>Natural Language Processing (NLP)</li>
                    <li><span class="underline">Knowledge Representation</span>: The abillity to represent knowledge using a set of symbols.</li>
                    <li><span class="underline">Automated Reasoning</span>: Solving a new problem using experiences gained from previous similar problems.</li>
                    <li>Machine Learning</li>
                </ol>
            <li><span class="underline">Systems that think rationally (thinking rationally)</span>: Aristotle, a philosopher, was the first person to attempt to codify "right" thinking through a system of deriving correct conclusions using accurate premises.</li>
            <li><span class="underline">Systems that act rationally (acting rationally)</span>: A rational agent is one which with the use of sensors perceives its environment and acts to achieve the best outcome possible in the given environment.</li>
            </li>
        </ol>
        <h3>Need of AI</h3>
        <p>
            Computers are used in several fields such as:
            <ol>
                <li>Numerical Computation</li>
                <li>Information Storage</li>
                <li>Repetitive Operations</li>
            </ol>
            But all these tasks are mindless and mechanical. Humans are much better than machines in performing intelligent tasks. 
        </p>
        <h3>Difference between knowledge and intelligence</h3>
        <table>
            <tr>
                <th><strong>Knowledge</strong></th>
                <th><strong>Intelligence</strong></th>
            </tr>
            <tr>
                <td>It can be defined as a piece of information that helps in intelligent decision making.</td>
                <td>The abillity to reason, trigger new thoughts, perceive and learn is called intelligence.</td>
            </tr>
        </table>
        <h3>Application areas of AI</h3>
        <p>
            The main application areas of AI are:
            <ol>
                <li>
                    <span class="underline">Natural Language Processing (NLP)</span> : To make a computer understand written text in human language. It involves only written language processing. Many computational techniques like
                    <ol>
                        <li>Morphological</li>
                        <li>Syntactic</li>
                        <li>Symantic</li>
                        <li>Pragmatic</li>
                    </ol>
                    are used for analysing naturally occurring text.<br>
                    Understanding spoken language is much harder than understanding written language.
                <hr>
                <h1>Refer to the block diagram for NLP in the notebook</h1>
                <hr>
                </li>
                <li>
                    <span class="underline">Expert Systems</span>: These are automatic consulting systems that provide expert conclusion about specialised areas like:
                    <ol>
                        <li>Business</li>
                        <li>Science</li>
                        <li>Engineering</li>
                        <li>Military</li>
                    </ol>
                    They are also sometimes responsible for the automation of following critical tasks:
                    <ol>
                        <li>Medical Diagnosis</li>
                        <li>Equipment Repair</li>
                        <li>Computer Configuration</li>
                        <li>Financial Planning</li>
                    </ol>
                </li>
                <li>
                    <span class="underline">Robotics</span>: It is the field of AI which enhances the abillity of a machine to move and act in the world with the same degree of responsiveness and flexibility as that of a human in the outside world.
                </li>
                <li>
                    <span class="underline">Theorem Proving</span>: Theorem proving is an intensive intellectual task because it requires deductions from hypothesis and also involves judgement, based on a large amount of specialised knowledge.
                </li>
                <li>
                    <span class="underline">Game Development</span>: AI is highly instrumental in game development as many games like tic-tac-toe or chess that require seeing patterns, making plans, searching combinations, judging alternative moves and learning from experience. 
                </li>
                <li>
                    <span class="underline">Computer Vision & Speech Recognition</span>:
                    <ol>
                        <li>
                            <span class="underline">Computer Vision</span>: Most sensor cameras provide the computer with 2D information of the world. But the world is 3D in nature and humans too perceive this world in 3 dimensions. Hence computer vision techniques are needed to provide the computer with the essential 3D knowledge of the world around it in order to make intelligent decisions.
                        </li>
                        <li>
                            <span class="underline">Speech Recognition</span>: is the abillity of the computer to 
                            <ol>
                                <li>accept spoken word as dictation or voice commands, and then</li>
                                <li>to respond accurately to these voice commands</li>        
                            </ol>
                        </li>
                    </ol>
                </li>
            </ol>
        </p>
        <h3>Objectives of AI</h3>
        <ol>
            <li>Cost-effective automation</li>
            <li>Cost-effective intelligence amplification</li>
            <li>Super-human intelligence</li>
            <li>General problem solving & learning</li>
            <li>Understand human cognition</li>
            <li>Intelligent information storage and retreival</li>
            <li><span class="underline">Coherent Discourse</span>: Communication using Natural Language Processing</li>
        </ol>
        <h3>AI Techniques</h3>
        <ol>
            <li><span class="underline">Search</span>: provides a way of solving problems for which no direct approach is available</li>
            <li><span class="underline">Use of Knowledge</span>: provides a way of solving complex problems by exploiting the structures of the objects that are involved</li>
            <li><span class="underline">Abstraction</span>: provides a way of separating important features and variations from many unimportant ones</li>
        </ol>
        <h3>Turing Test</h3>
        <hr>
        <h1>Refer to the diagram for Turing Test in the notebook</h1>
        <hr>
        <p>
            Alan Turing proposed an imitation game which we refer to as Turing Test to check a machine's intelligence. Turing Test verfies/ measures the performance of a machine, in terms of intelligence, against that of a human.
            <br>
            In this test, there will be a machine (A) and a human (B). Both will be in different rooms. Further there would be an interrogator (C) who is not able to talk to A or B directly. All A, B and C use a textual device to talk to each other.
            <br>
            Different questions/ queries of different complexities are asked by the interrogator. Based on the response provided by A and B, C will check the correctness of the response. At the end if C is not able to differentiate between the machine and human then it'll be said that the machine is intelligent.
            <br><br>
            <strong>Criticism of Turing Test</strong>
            <br>
            <ol>
                <li>Intelligence should be defined in a positive sense, for example, for a machine to do the assigned work properly and efficiently. Befooling someone is not intelligence. </li>
                <li>Incorporating intelligence in a machine means developing the abillity in the machine to accomplish the task faster. Turing Test does not talk about the performance (in terms of speed) of the system. It simply measures the intelligence level of the machine.</li>
                <li>A computer's performance is also measured in terms of space or memory it requires in order to perform the assigned tasks. It is well known that the computer is much better in terms of memory management and retention than us humans. However the Turing Test does not discuss anything on this aspect.</li>
            </ol>
        </p>
        <h3>Another similar test: Chinese Room Experiment</h3>
        <p>
            Chinese Room Experiment was proposed to exhibit the fact that a system running and passing the Turing Test might not have understanding.
            <br>
            In this experiment a human who didn't know Chinese was locked in a room with a set of Chinese alphabets. Then he was provided with a small story, in which a few instructions were present in English to correlate the two sets of symbols. At the end he was provided with a set of questions to be answered, supported by instructions in English.
            <br>
            The human provided very satisfactory answers to the questions in Chinese provided even when he had no formal knowledge of the language, thereby creating the illusion that the person knew Chinese.
            <br>
            According to Turing Test, this machine should be considered intelligent. However, we can clearly see that the machine was simply involved in manipulation of the formal symbols of the language in a way that lacked any understanding on part of the machine.
        </p>
        <h3>Components of AI</h3>
        <ol>
            <li class="underline">Theoretical Components</li>
                <ol>
                    <li>Problem solving using heuristic techniques</li>
                    <li>Knowledge representation using symbols</li>
                    <li>Theorem Proving</li>
                    <li>Natural Language Proving (NLP)</li>
                    <li>Game Playing</li>
                    <li>Expert Systems</li>
                    <li>Computer Vision</li>
                </ol>
            <li class="underline">Software Components</li>
                <ol>
                    <li>Machine, Assembly and High-level language</li>
                    <li>OOP concepts</li>
                </ol>
        </ol>
        <h3>Comparison between Computer and Human Skills</h3>
        <ol>
            <li><span class="underline">Computer Skills</span>
                <ol>
                    <li>Can efficiently handle big numerical computation</li>
                    <li>Can efficiently handle large amount of information storage</li>
                    <li>Can efficiently perform a task repeatedly</li>
                </ol>
            </li>
            <li><span class="underline">Human Skills</span>
                <ol>
                    <li>Flexible reaction in any situation</li>
                    <li>Find similarities between situations despite differences which may separate them</li>
                    <li>Find differences between situations despite similarities which may link them</li>
                </ol>
            </li>
        </ol>
        <h3>Types of AI</h3>
        <ol>
            <li>
                <span class="underline">Strong AI</span>: believes that it is possible for machines to become self-aware and to think almost equally in abillity to that of a human.
            </li>
            <li>
                <span class="underline">Weak AI</span>: belives that some thinking abillity can be added to computers to make them more useful tools for specific problem solving or reasoning tasks, even if it doesn't emcompass the entire range of human cognitive abillity.<br>
                Eg. Making the computer able to play chess.  
            </li>
        </ol>
        <h3>Practical Systems based on AI</h3>
        <ol>
            <li><strong>Autonomous Vehicles</strong> (in a project funded by DARPA)</li>
            <li><strong>Computer Chess</strong> (Deep Blue by IBM deafeated World Chess Champion Gary Kasparov)</li>
            <li><strong>Mathematical Theorem Proving</strong> (Computer system at Argonne National Lab proved a mathematical conjencture on algebra)</li>
            <li><strong>Advanced User Interface</strong> (PEGAUSS a spoken language interface to American Airlines Reservation System)</li>
        </ol>
        <br>
        <h2>Part 2: Problem Solving through AI</h2>
        <br>
        AI systems have been developed which solve problems in a specific domain. However most real-world problems encompass different domains and hence AI systems that can solve real world problems are still in development. Following are some terms used in AI problem solving:
        <ol>
            <li><span class="underline">Problem</span>: What is to be solved</li>
            <li><span class="underline">Search Space</span>: Complete set of states including the start and goal states, where the solution to the problem is to be searched</li>
            <li><span class="underline">Search</span>: Process of finding the solution in search space</li>
            <li>
                <span class="underline">Well-defined problem</span>: A well-defined problem can be described by th following
                <ol>
                    <li>Initial State</li>
                    <li>Goal State</li>
                    <li><span class="underline">Operator or Successor Function</span>: The successor function, for any state X, returns S(X), i.e. the set of states immediately reachable from X.</li>
                    <li><span class="underline">State Space</span>: Set of all states reachable from the intial state.</li>
                    <li><span class="underline">Path</span>: Sequence of states traversed through the state space.</li>
                    <li><span class="underline">Path Cost</span>: Cost of a path traversed is the sum of costs of individual actions taken to traverse along that path.</li>
                    <li><span class="underline">Goal Test</span>: Test to determine whether a given state is the goal state, from a set of possible goal states</li>
                </ol>
            </li>
        </ol>
        <h3>Steps in AI Problem Solving Methodology</h3>
        <ol>
            <li>
                <span class="underline">Problem Definition</span>: The problem definition must include precise specifications of the intial and the final status of the problem, as well as the various possible intermediate states and corresponding knowledge representation. Some features of good representation are:
                <ol>
                    <li>Good representations bring objects and relationships together, describing their features and corresponding relationships</li>
                    <li>Good representations suppress irrelevant details in the problem</li>
                    <li>Good representations are <strong>concise</strong> and <strong>complete</strong></li>
                    <li>Good representations take up minimum memory space</li>
                    <li>Good representations are complete</li>
                </ol>
            </li>
            <li>
                <span class="underline">Problem Analysis</span>: This step helps in abstracting the salient features of the problem that can have an immense impact on deciding the appropriateness of the various possible techniques available for solving the problem.<br>
                For eg. In game playing, selection of a winning move involves analysis of the opponent's move.
            </li>
            <li>
                <span class="underline">Knowledge Representation</span>: As we know that the solution of a given problem requires the availability of of related knowledge. Hence, isolation and representation of the knowledge at hand is necessary to solve a problem, as covered in this step.<br>
                Depending upon the problem, different types of knowledge might be needed and hence the representation techniques might differ. For eg. 8-queens problem requires storing only the queen's position on the board whereas a NLP application would require the syntax and symantic details of the respective grammar for that language.
            </li>
            <li>
                <span class="underline">Problem Solving</span>: Using the knowledge gathered, choose the best problem solving technique (also called as the search technique) and apply it to the given problem.
            </li>
        </ol>
        <h3>Representation of AI Problems</h3>
        <ol>
            <li>
                <span class="underline">Lexical Part</span>: determines which symbols are allowed in the representation of the problem.<br>
                For eg. In chess, this part would contain the possible 8x8 board positions.
            </li>
            <li>
                <span class="underline">Structural Part</span>: describes constraints on how the symbols, determined above, can be arranged.<br>
                For eg. In chess, this part would contain the set of legal moves, which provide a way of getting from an initial state to a goal position.
            </li>
            <li>
                <span class="underline">Procedural Part</span>: specifies the set of procedural steps that would help solve us a given problem.<br>
                For eg. In chess, this part would contain the set of moves, out of all the possible moves, that would help us bring the board position to a winning position. 
            </li>
            <li>
                <span class="underline">Semantic Part</span>: establishes a way of associating meaning with steps taken in solving a problem.<br>
                For eg. In chess there is never a hidden meaning behind any move. However in an NLP application there is a "message" associated with any sentence which needs represntation.
            </li>
        </ol>
        <h3>Defining problems as a State Space Search</h3>
        The following steps are involved in formally defining a problem as a state space search:
        <ol>
            <li><span class="underline">Defining State Space</span>: conatins all possible set of states reachable from the initial state</li>
            <li>Initial State</li>
            <li>Goal State</li>
            <li><span class="underline">Operators (Rules) </span>: set of rules that define the actions available</li>
        </ol>
        <h3>Production System?</h3>
        An AI System developed for solution of any problem is called a production system.<br>
        Once a problem is suitably analysed and represented, the production system is used for applying the rules and obtaining the solution. A production system consists of the following components:
        <ol>
            <li>
                <span class="underline">Set of Production Rules</span>: Production rules are of the form P -> Q.<br>
                The left hand side of the rule determines the <em>applicability</em> of the rule and the right hand side describes the <em>output</em>, if the rule is applied.
            </li>
            <li><span class="underline">Global Database</span>: One or more knowledge databases exist which contain all the information for the solution of the particular problem at hand.</li>
            <li><span class="underline">Control Strategy</span>: It specifies the order in which the rules will be picked from the database and applied so as to obtain a solution to a given problem in a way such that no conflicts arise when several rules are picked simultaneously.</li>
            <li><span class="underline">Rule Application</span>: Finally out of all the rules picked, the applicability of the rule(s) is checked by matching the current state with the LHS of the rule.</li>
        </ol>
        <h3>Features of Production Rules</h3>
        <ol>
            <li>Simplicity</li>
            <li>Expressiveness & Intuitiveness</li>
            <li>Conflict Resolution</li>
            <li>Modularity & Modifiability</li>
            <li>Knowledge Intensive</li>
        </ol>
        <h3>Characteristics of Production System</h3>
        <ol>
            <li>
                <span class="underline">Data Structures</span>: After the definition of a problem, it should be represented in a suitable data structure for easy visualisation and solution-finding. Trees and graphs are often used for this purpose. In such a case, the different nodes correspond to the different attainable problem states, while the arrows correspond to the valid transitions between those states.
            </li>
            <li>
                <span class="underline">Control Strategies</span>: Also known as search strategies, control strategy is responsible for obtaining the solution of the problem. Various characteristics of a control strategy are:
                <ol>
                    <li>A good control strategy should always cause motion, i.e. the problem should always move towards it's solution on the application of a control strategy.</li>
                    <li>A good control strategy should be systematic, i.e. the general selection of a rule for the solution for a problem should always be systematic.</li>
                </ol>
            </li>
        </ol>
        <h3>General algorithm of Problem Solving</h3>
        <ol>
            <li>Choose an appropriate data structure for representing the initial state, goal state and the corresponding production rules from the knowledge database.</li>
            <li>Until the goal is achieved, perform the following</li>
            <li>Begin</li>
            <li>Select a suitable rule from the set of rules and apply it to the data</li>
            <li>Make the new attained state as the current state</li>
            <li>End</li>
        </ol>
        <br>
        <h2>Part 3: Examples of AI Problems</h2>
        <br>
        <h3>Tic-Tac-Toe</h3>
        <span class="underline">Problem Statement</span>: This game has two players, "X" and "O" and a board of 9 squares. Each square can be filled by either of the two players in a way that no square is over-written if it's already filled. One of the two players may win if they manage to make their mark in one of the rows, columns or diagonals entirely.<br><br>
        In terms of AI, this problem can be represented as below:
        <ol>
            <li>
                <span class="underline">Data Structure</span>: A 9 element array (vector) is used to represent the the 9 different board positions in the following way:<br>
                Board Positions: {1,2,3,4,5,6,7,8,9}<br>
                Any valid/ legal state is represented in accordance with the following rules:
                <ol>
                    <li>A board position is represented with '0' if it's a blank, unfilled position</li>
                    <li>A board position is represented with '1' if it's filled with 'O'</li>
                    <li>A board position is represented with '2' if it's filled with 'X'</li>
                </ol>
                So the starting state is always {O,O,O,O,O,O,O,O,O}
                Winning state will always contain the following similarly occupied combinations:
                <ol>
                    <li>{1,2,3}</li>
                    <li>{4,5,6}</li>
                    <li>{7,8,9}</li>
                    <li>{1,4,7}</li>
                    <li>{2,5,8}</li>
                    <li>{3,6,9</li>
                    <li>{1,5,9}</li>
                    <li>{3,5,7}</li>
                </ol>
                Hence two possible goal states are {<span class="underline">2</span>,0,1,1,<span class="underline">2</span>,0,0,0,<span class="underline">2</span>} (corresponding to 7th bullet above) or {<span class="underline">2</span>,<span class="underline">2</span>,<span class="underline">2</span>,0,1,0,1,0,0} (correspoding to 1st bullet above)
            </li>
            <li>
                <span class="underline">Operator</span>: Change an empty cell to either 'X' or 'O'.
            </li>
            <li>
                <span class="underline">State Space</span>: Every possible state in the transition table will be a vector having 9 elements each.
            </li>
        </ol>
        <h3>Water-Jug Problem</h3>
        <span class="underline">Problem Statement</span>: We have two water jugs with no measuring marks on them. The capacities of the jugs are 3 litre and 4 litre. It is required to fill the bigger jug with 2 litre of water. You may use extra water for this purpose from a water source given to you.<br><br>
        In the terms of AI, this problem can be represented as below:
        <ol>
            <li>
                <span class="underline">State Space</span>: In this problem, we can use ordered pairs as (x,y) to depict the amount of water in the two jugs, where
                <ol>
                    <li><strong>x</strong> represents the amount of water in the 4 litre jug</li>
                    <li><strong>y</strong> represents the amount of water in the 3 litre jug</li>
                </ol>
                So
                <ol>
                    <li><span class="underline">Start State</span>: (0,0)</li>
                    <li><span class="underline">Goal State</span>: (2,0)</li>
                </ol>
            </li>
            <li>
                <span class="underline">Possible Production Rules</span>: are as following
                <ol>
                    <li><strong>(x, y) -> (4, y)</strong>: Fill the 4 litre jug entirely</li>
                    <li><strong>(x, y) -> (x, 3)</strong>: Fill the 3 litre jug entirely</li>
                    <li><strong>(x, y) -> (x-d, y)</strong>: Pour some water out from the 4 litre jug</li>
                    <li><strong>(x, y) -> (x, y-d)</strong>: Pour some water out from the 3 litre jug</li>
                    <li><strong>(x, y) -> (0, y)</strong>: Empty the 4 litre jug</li>
                    <li><strong>(x, y) -> (x, 0)</strong>: Empty the 3 litre jug</li>
                    <li><strong>(x, y) -> (4, y-(4-x))</strong>: Fill the 4 litre jug using 3 litre jug until 4 litre jug is full</li>
                    <li><strong>(x, y) -> (x-(3-y), 3)</strong>: Fill the 3 litre jug using 4 litre jug until 3 litre jug is full</li>
                    <li><strong>(x, y) -> (x+y, 0)</strong>: Pour all water from 3 litre jug into 4 litre jug</li>
                    <li><strong>(x, y) -> (0, x+y)</strong>: Pour all water from 4 litre jug into 3 litre jug</li>
                    <li><strong>(0, 2) -> (2, 0)</strong>: Pour 2 litre from 3 litre jug into 4 litre jug</li>
                    <li><strong>(2, y) -> (0, y)</strong>: Empty 2 litres of water from 4 litre jug on the ground</li>
                </ol>
            </li>
        </ol>
        <span class="underline">Solution</span>: as below<br><br>
        <table>
            <tr>
                <th>Rule Applied</th>
                <th>Water in 4 litre jug</th>
                <th>Water in 3 litre jug</th>
            </tr>
            <tr>
                <td>Start State</td>
                <td>0</td>
                <td>0</td>
            </tr>
            <tr>
                <td>2</td>
                <td>0</td>
                <td>3</td>
            </tr>
            <tr>
                <td>9</td>
                <td>3</td>
                <td>0</td>
            </tr>
            <tr>
                <td>2</td>
                <td>3</td>
                <td>3</td>
            </tr>
            <tr>
                <td>7</td>
                <td>4</td>
                <td>2</td>
            </tr>
            <tr>
                <td>5</td>
                <td>0</td>
                <td>2</td>
            </tr>
            <tr>
                <td>9</td>
                <td>2</td>
                <td>0</td>
            </tr>
        </table>
        <br>
        <h3>8-Puzzle Problem</h3>
        <span class="underline">Problem Statement</span>: There's a 3x3 board having 9 block spaces. Out of those 9 block spaces, 8 are filled with a number each, while one space is left blank. Our aim is to arrange the tiles in an ordered sequence. The only operation we can perform is shifting any tile to an adjacent empty block space.<br>
        <blockquote>
            <em>
                <ol>
                    <li>What we actually need to do is generate a search tree for the start state.</li>
                    <li>We DO NOT move the elements already in place. We instead move our BLANK. The blank can shift in at max 4 possible positions: north, south, east, west.</li>
                    <li>We derive a new state with every move of the blank. For eg. if we have a state containing the blank, free to move in 4 directions (as mentioned above), we will derive 4 NEW states out of that initial state.</li>
                    <li>We then compare these 4 states with each other with the purpose of choosing the best state out of them so as to proceed further in our process of finding the solution. BUT HOW DO WE COMPARE THEM?</li>
                    <li>Keep the goal state in mind when analysing every state. For every element out of it's place with respect to the goal state, we calculate it's displacement from it's assigned place. The state with the least displacement gets chosen for the next step.</li>
                    <li>The fundamental idea of operation is that if we keep choosing and moving forwad with the best available state at hand at every step, we will eventually end up at the solution state.</li>
                </ol>
            </em>
        </blockquote>
        <ol>
            <li>
                So the start and goal states for the problem could be
                <ol>
                    <li>
                        <span class="underline">Start State</span>: It can be any configuration. Let us take the start state to be<br><br>
                        <table class="state_box">
                            <tr>
                                <td>2</td>
                                <td>8</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>1</td>
                                <td>6</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>7</td>
                                <td>_</td>
                                <td>5</td>
                            </tr>
                        </table>
                    </li>
                    <br>
                    <li>
                        <span class="underline">Goal State</span>: Given the rules and the above start state, the corresponding goal state would look like<br><br>
                        <table class="state_box">
                            <tr>
                                <td>1</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>8</td>
                                <td>_</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>7</td>
                                <td>6</td>
                                <td>5</td>
                            </tr>
                        </table>
                    </li>
                </ol>
            </li>
            <br>
            <li>
                <span class="underline">Production Rules</span>: are as following
                <ol>
                    <li>
                        <strong>(mov1, mov2, mov3, mov4) -> (mov1)</strong> if wt(mov1) > wt(mov2) & wt(mov3) & wt(mov4)
                    </li>
                    <li>
                        <strong>(mov1, mov2, mov3, mov4) -> (mov2)</strong> if wt(mov2) > wt(mov1) & wt(mov3) & wt(mov4)
                    </li>
                    <li>
                        <strong>(mov1, mov2, mov3, mov4) -> (mov3)</strong> if wt(mov3) > wt(mov1) & wt(mov2) & wt(mov4)
                    </li>
                    <li>
                        <strong>(mov1, mov2, mov3, mov4) -> (mov4)</strong> if wt(mov4) > wt(mov1) & wt(mov2) & wt(mov3)
                    </li>
                </ol>
                So ultimately,
                <strong>
                    <table class="production_rules">
                        <tr>
                            <td></td>
                            <td>mov1 or mov2</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>mov2 or mov3</td>
                        </tr>
                        <tr>
                            <td>(mov1, mov2, mov3, mov4) -> </td>
                            <td>mov3 or mov4</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>mov1 or mov3</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>mov2 or mov4</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td>mov1 or mov4</td>
                        </tr>
                    </table>
                </strong>
            </li>
            <br>
            <li>
                <span class="underline">Problem Solution</span>: So solving the given problem at hand,
                <hr>
                Intial State:
                <br><br>
                <table class="state_box">
                    <tr>
                        <td>2</td>
                        <td>8</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>6</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>_</td>
                        <td>5</td>
                    </tr>
                </table>
                <br>
                <hr>
                Step 1:
                <br>
                <div style="display: inline-block; width: 32%">
                   <br>(a)
                    <table class="state_box">
                        <tr>
                            <td>2</td>
                            <td>8</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>6</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>_</td>
                            <td>7</td>
                            <td>5</td>
                        </tr>
                    </table>
                    <br>
                    <div class="text_center">Displacement = 6</div>
                </div>
                <div style="display: inline-block; width: 32%">
                   <br>(b)
                    <table class="state_box">
                        <tr>
                            <td>2</td>
                            <td>8</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>_</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>6</td>
                            <td>5</td>
                        </tr>
                    </table>
                    <br>
                    <div class="text_center">Displacement = 4</div>
                </div>
                <div style="display: inline-block; width: 32%">
                   <br>(c)
                    <table class="state_box">
                        <tr>
                            <td>2</td>
                            <td>8</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>6</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>5</td>
                            <td>_</td>
                        </tr>
                    </table>
                    <br>
                    <div class="text_center">Displacement = 6</div>
                </div>
                <blockquote style="text-align: center;">
                    Displacement of a state is always calculated by the sum of the distances of the number of elements NOT in their right position, from their correct position as in the goal state.<br><br>
                    Since (b) has the least score, we choose (b) for the next step.
               </blockquote>
               <hr>
               Step 2:
                <br>
                <div style="display: inline-block; width: 23%">
                   <br>(a)
                    <table class="state_box">
                        <tr>
                            <td>2</td>
                            <td>8</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>_</td>
                            <td>1</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>6</td>
                            <td>5</td>
                        </tr>
                    </table>
                    <br>
                    <div class="text_center">Displacement = 5</div>
                </div>
                <div style="display: inline-block; width: 23%">
                   <br>(b)
                    <table class="state_box">
                        <tr>
                            <td>2</td>
                            <td>_</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>8</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>6</td>
                            <td>5</td>
                        </tr>
                    </table>
                    <br>
                    <div class="text_center">Displacement = 3</div>
                </div>
                <div style="display: inline-block; width: 23%">
                   <br>(c)
                    <table class="state_box">
                        <tr>
                            <td>2</td>
                            <td>8</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>4</td>
                            <td>_</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>6</td>
                            <td>5</td>
                        </tr>
                    </table>
                    <br>
                    <div class="text_center">Displacement = 5</div>
                </div>
                <div style="display: inline-block; width: 23%">
                   <br>(c)
                    <table class="state_box">
                        <tr>
                            <td>2</td>
                            <td>8</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>6</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>_</td>
                            <td>5</td>
                        </tr>
                    </table>
                    <br>
                    <div class="text_center">Displacement = 5</div>
                </div>
                <blockquote style="text-align: center;">
                    We go forward with State (b).
               </blockquote>
               <hr>
                Step 3:
                <br>
                <div style="display: inline-block; width: 32%">
                   <br>(a)
                    <table class="state_box">
                        <tr>
                            <td>2</td>
                            <td>3</td>
                            <td>_</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>8</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>6</td>
                            <td>5</td>
                        </tr>
                    </table>
                    <br>
                    <div class="text_center">Displacement = 4</div>
                </div>
                <div style="display: inline-block; width: 32%">
                   <br>(b)
                    <table class="state_box">
                        <tr>
                            <td>2</td>
                            <td>8</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>_</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>6</td>
                            <td>5</td>
                        </tr>
                    </table>
                    <br>
                    <div class="text_center">Displacement = 4</div>
                </div>
                <div style="display: inline-block; width: 32%">
                   <br>(c)
                    <table class="state_box">
                        <tr>
                            <td>_</td>
                            <td>2</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>8</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>6</td>
                            <td>5</td>
                        </tr>
                    </table>
                    <br>
                    <div class="text_center">Displacement = 2</div>
                </div>
                <blockquote style="text-align: center;">
                    We go with state (c).
               </blockquote>
               <hr>
                Step 4:
                <br>
                <div style="display: inline-block; width: 49%">
                   <br>(a)
                    <table class="state_box">
                        <tr>
                            <td>1</td>
                            <td>2</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>_</td>
                            <td>8</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>6</td>
                            <td>5</td>
                        </tr>
                    </table>
                    <br>
                    <div class="text_center">Displacement = 1</div>
                </div>
                <div style="display: inline-block; width: 49%">
                   <br>(b)
                    <table class="state_box">
                        <tr>
                            <td>2</td>
                            <td>_</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>8</td>
                            <td>4</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>6</td>
                            <td>5</td>
                        </tr>
                    </table>
                    <br>
                    <div class="text_center">Displacement = 3</div>
                </div>
                <blockquote style="text-align: center;">
                    We go with state (a).
               	</blockquote>
               	<hr>
                Hence we finally get the goal state:
                <br><br>
                <table class="state_box">
                    <tr>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td>8</td>
                        <td>_</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>6</td>
                        <td>5</td>
                    </tr>
                </table>
            </li>
        </ol>
        <br>
        <h3>Missionaries and Cannibals Problem</h3>
        <hr>
        <h2 class="part_not_understood">THIS PROBLEM HAS AN ALTERNATIVE SOLUTION, AS GIVEN BELOW</h2>
        <div style="width: 49%; display: inline-block;">
            <span style="display: block; text-align: center; color: red;">Solution, as given in notes</span><br>
            <table style="min-width: 20%;" class="part_not_understood">
                <tr>
                    <th>Bank 1</th>
                    <th>Bank 2</th>
                </tr>
                <tr>
                    <td>MMMCCC</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>MMMCC</td>
                    <td>C</td>
                </tr>
                <tr>
                    <td>MMMC</td>
                    <td>CC</td>
                </tr>
                <tr>
                    <td>MMCC</td>
                    <td>MC</td>
                </tr>
                <tr>
                    <td>CCC</td>
                    <td>MMM</td>
                </tr>
                <tr>
                    <td>CC</td>
                    <td>MMMC</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>MMMCCC</td>
                </tr>
            </table>
        </div>
        <div style="width: 49%; display: inline-block;">
            <span style="display: block; text-align: center; color: red;">Alternative Solution</span><br>
            <table style="min-width: 20%;" class="part_not_understood">
                <tr>
                    <th>Bank 1</th>
                    <th>Bank 2</th>
                </tr>
                <tr>
                    <td>MMMCCC</td>
                    <td>0</td>
                </tr>
                <tr>
                    <td>MMMCC</td>
                    <td>C</td>
                </tr>
                <tr>
                    <td>MMCC</td>
                    <td>MC</td>
                </tr>
                <tr>
                    <td>CCC</td>
                    <td>MMM</td>
                </tr>
                <tr>
                    <td>CC</td>
                    <td>MMMC</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>MMMCCC</td>
                </tr>
            </table>
        </div>
        <br><br>
        <hr>
        <span class="underline">Problem Statement</span>: Three missionaries and three cannibals are standing on one side and need to cross the river. There is only one boat avaialable, which can carry a max of 2 people at a time. Also at any point of the time, the number of cannibals must not exceed the number of missionaries on either of the banks.
        <br><br>
        Let us work towards obtaining a solution for the problem at hand, with the sign conventions as:
        <ul>
            <li>
                <strong>M</strong>: Missionary
            </li>
            <li>
                <strong>C</strong>: Cannibal
            </li>
        </ul>
        <ol>
            <li>
                <span class="underline">Production Rules</span>: for this problem are as following
                <br><br>
                <table style="min-width: 90%;">
                    <tr>
                        <th></th>
                        <th>Bank 1</th>
                        <th>Boat</th>
                        <th>Bank 2</th>
                    </tr>
                    <tr>
                        <td>Start State</td>
                        <td>(3M, 3C)</td>
                        <td>(0M, 0C)</td>
                        <td>(0M, 0C)</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>(2M, 3C)</td>
                        <td>(1M, 0C)<br>*from bank 1 to 2*</td>
                        <td>(1M, 0C)</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>(2M, 3C)</td>
                        <td>(1M, 0C)<br>*from bank 2 to 1*</td>
                        <td>(1M, 0C)</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>(1M, 3C)</td>
                        <td>(2M, 0C)<br>*from bank 1 to 2*</td>
                        <td>(2M, 0C)</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>(1M, 3C)</td>
                        <td>(2M, 0C)<br>*from bank 2 to 1*</td>
                        <td>(2M, 0C)</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>(2M, 2C)</td>
                        <td>(1M, 1C)<br>*from bank 1 to 2*</td>
                        <td>(1M, 1C)</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>(2M, 2C)</td>
                        <td>(1M, 1C)<br>*from bank 2 to 1*</td>
                        <td>(1M, 1C)</td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>(3M, 1C)</td>
                        <td>(0M, 2C)<br>*from bank 1 to 2*</td>
                        <td>(0M, 2C)</td>
                    </tr>
                    <tr>
                        <td>8</td>
                        <td>(3M, 1C)</td>
                        <td>(0M, 2C)<br>*from bank 2 to 1*</td>
                        <td>(0M, 2C)</td>
                    </tr>
                    <tr>
                        <td>9</td>
                        <td>(3M, 2C)</td>
                        <td>(0M, 1C)<br>*from bank 1 to 2*</td>
                        <td>(0M, 1C)</td>
                    </tr>
                    <tr>
                        <td>10</td>
                        <td>(3M, 2C)</td>
                        <td>(0M, 1C)<br>*from bank 2 to 1*</td>
                        <td>(0M, 1C)</td>
                    </tr>
                </table>
            </li>
            <br>
            <li>
                <span class="underline">Sequence of Rule Application & Solution</span>: as below
                <br><br>
                <table>
                    <tr>
                        <td>Production Rule Application & Problem State</td>
                        <td>People at River Bank 1</td>
                        <td>People at River Bank 2</td>
                        <td>Boat Position</td>
                    </tr>
                    <tr>
                        <td>Start State</td>
                        <td>M, M, M, C, C, C</td>
                        <td>0</td>
                        <td>Bank 1</td>
                    </tr>
                    <tr>
                        <td>Rule #5</td>
                        <td>M, M, C, C</td>
                        <td>M, C</td>
                        <td>Bank 2</td>
                    </tr>
                    <tr>
                        <td>Rule #2</td>
                        <td>M, M, C, C, M</td>
                        <td>C</td>
                        <td>Bank 1</td>
                    </tr>
                    <tr>
                        <td>Rule #7</td>
                        <td>M, M, M</td>
                        <td>C, C, C</td>
                        <td>Bank 2</td>
                    </tr>
                    <tr>
                        <td>Rule #10</td>
                        <td>M, M, M, C</td>
                        <td>C, C</td>
                        <td>Bank 1</td>
                    </tr>
                    <tr>
                        <td>Rule #3</td>
                        <td>M, C</td>
                        <td>C, C, M, M</td>
                        <td>Bank 2</td>
                    </tr>
                    <tr>
                        <td>Rule #6</td>
                        <td>M, C, M, C</td>
                        <td>C, M</td>
                        <td>Bank 1</td>
                    </tr>
                    <tr>
                        <td>Rule #3</td>
                        <td>C, C</td>
                        <td>C, M, M, M</td>
                        <td>Bank 2</td>
                    </tr>
                    <tr>
                        <td>Rule #10</td>
                        <td>C, C, C</td>
                        <td>M, M, M</td>
                        <td>Bank 1</td>
                    </tr>
                    <tr>
                        <td>Rule #7</td>
                        <td>C</td>
                        <td>M, M, M, C, C</td>
                        <td>Bank 2</td>
                    </tr>
                    <tr>
                        <td>Rule #10</td>
                        <td>C, C</td>
                        <td>M, M, M, C</td>
                        <td>Bank 1</td>
                    </tr>
                    <tr>
                        <td>Rule #7</td>
                        <td>0</td>
                        <td>M, M, M, C, C</td>
                        <td>Bank 2</td>
                    </tr>
                </table>
                <br>
                <blockquote class="text_center">
                    For problem rule application, please refer to bullet #1
                </blockquote>
            </li>
        </ol>
        <br>
        <h3>The Monkey Banana Problem</h3>
        <hr>
        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
        <p style="display: inline-block; margin: 0 auto; text-align: center; color: orange;">Please refer to the <strong>state transition diagram</strong> mentioned in the notes for this problem</p>
        <hr>
        <span class="underline">Problem Statement</span>: is as below
        <ol>
            <li>There is a monkey at the door of a room.</li>
            <li>In the middle of the room, from the ceiling, hang a bunch of bananas.</li>
            <li>The monkey is hungry and wants to eat the bananas. However he cannot stretch or jump high enough from the floor itself so as to snatch the bunch of bananas hanging from the ceiling.</li>
            <li>There is a window in the room. Near that window lies a box which the monkey may use to get the bananas.</li>
        </ol>
        <ol>
            <li>
                <span class="">State Space Representation</span>: as below
                <ol>
                    <li>
                        <span class="underline">Position of the monkey</span> : represented by <strong>M</strong>
                    </li>
                    <li>
                        <span class="underline">Position of the box</span> : represented by <strong>B</strong>
                    </li>
                    <li>
                        <span class="underline">Whether the monkey is on the box</span> : represented by <strong>X</strong>. If the monkey is on the box, <strong>X = 1</strong>. Else <strong>X = 0</strong>.
                    </li>
                    <li>
                        <span class="underline">Whether the monkey has the bananas or not</span> : represented by <strong>Y</strong>. If the monkey has the bananas, <strong>Y = 1</strong>. Else <strong>Y = 0</strong>.
                    </li>
                </ol>
                Hence
                <ol>
                    <li>
                        <span class="underline">Initial State</span>: (door, windows, 0, 0)
                    </li>
                    <li>
                        <span class="underline">Goal State</span>: (*, *, *, 1)
                    </li>
                </ol>
                <blockquote style="text-align: center;">
                    Here * is a state space variable where it could mean anything. The only constant in the goal state is that the monkey must have the bananas with him, as indicated by Y = 1.
                </blockquote>
            </li>
            <li>
                <span class="underline">Production Rules</span>: as below
                <br><br>
                <table style="min-width: 90%;">
                    <tr>
                        <th>Initial State</th>
                        <th style="width: 27%;">Action/ Operator</th>
                        <th>End State</th>
                        <th>Description/ Remark</th>
                    </tr>
                    <tr>
                        <td>(M, B, 0, 0)</td>
                        <td>---- walk (P) ----></td>
                        <td>(P, B, 0, 0)</td>
                        <td><strong>Walk (P)</strong>: Monkey goes to any position P</td>
                    </tr>
                    <tr>
                        <td>(M, M, 0, 0)</td>
                        <td>---- walk (V) ----></td>
                        <td>(V, V, 0, 0)</td>
                        <td><strong>Push (V)</strong>: Push box to any position V</td>
                    </tr>
                    <tr>
                        <td>(M, M, 0, 0)</td>
                        <td>---- climb ----></td>
                        <td>(M, M, 1, 0)</td>
                        <td><strong>Climb</strong>: Monkey climbs the box to reach for the bananas</td>
                    </tr>
                    <tr>
                        <td>(M, M, 1, 0)</td>
                        <td>---- grasp ----></td>
                        <td>(M, M, 1, 1)</td>
                        <td><strong>Grasp</strong>: Monkey grasps the bunch of bananas</td>
                    </tr>
                </table> 
            </li>
        </ol>
        <br>
        <h3>8-Queen Problem</h3>
        <span class="underline">Problem Statement</span>: We have 8 queens on a 8x8 chessboard. Any queen can attack any other queen in the same row, column or diagonal. Hence in this problem we have to find the proper placement of queens on the chessboard in such a way that no two queens attack each other.
        <ol>
            <li>
                <span class="underline">State Representation</span>: Arrangement of the 8 queens on the board is a state.
            </li>
            <li>
                <span class="underline">Initial State</span>: Empty chessboard with no queens.
            </li>
            <li>
                <span class="underline">Successor Function</span>: Add a queen to an empty square.
            </li>
            <li>
                <span class="underline">Goal State</span>: With all 8 queens on the chessboard, they are so positioned that no two queens can attack each other.
            </li>
        </ol>
        <br>
        <h3>Travelling Salesman Problem</h3>
        <span class="underline">Problem Statement</span>: A salesperson is required to travel to a certain given number of cities, with their respective inter-city distances specified to us. We are required to find the shortest route possible for the salesman to travel in such a way that the salesman can travel all the cities exactly once and come back to the city he started with.
        <ul>
            <li>
                <span class="underline">Possible Solutions</span>: are as below
                <br><br>
                <table style="min-width: 40%;">
                    <tr>
                        <th>No. of Cities</th>
                        <th>Routes</th>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>1-2-1</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>1-2-3-1<br>1-3-2-1</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>1-2-3-4-1<br>1-3-2-4-1<br>1-3-4-2-1<br>1-2-4-3-1<br>1-4-3-2-1<br>1-4-2-3-1</td>
                    </tr>
                </table>
                <blockquote style="text-align: center;">
                    We can see that the number of routes between cities is proportional to the factorial of (no. of cities - 1). So as the no. of cities increase, Travelling Salesman Problem becomes a NP Hard problem. We will later try and solve this problem using the Heuristic technique.
                </blockquote>
            </li>
        </ul>
        <br>
        <h3>Tower of Hanoi Problem</h3>
        <hr>
        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
        <p style="display: inline-block; margin: 0 auto; text-align: center; color: orange;">Please refer to the the diagrammatic representation for the initial and goal states for this problem, in the notes. Also have a run-through of the problem from any tutorial on YouTube.</p>
        <hr>
        <span class="underline">Problem Statement</span>: There can be differing number of poles and disks in this problem, hence for this problem we're going to limit ourselves to a problem with 3 poles and 3 disks.<br>
        The problem has 3 poles in consideration. There are 3 disks, of differing sizes on the left-most pole, called the source pole, in a decreasing order of size from bottom to top (largest disk on the bottom, smallest on the top). The objective is to transfer these disks in the same order to the right-most pole, using the middle pole. No larger disk can sit on a smaller disk under any circumstances.
        <br><br>
        <h3>Chess</h3>
        <ol>
            <li>
                <span class="underline">Start State</span>: Any random inital configuration of the chess board 
            </li>
            <li>
                <span class="underline">Goal State</span>: Any board configuration which presents an opportunity to the player to win the game
            </li>
            <li>
                <span class="underline">State Space</span>: Whenever any player moves a piece it gives rise to a different state of the game. A chess game can have 10<sup>120</sup> possible states. 
            </li>
        </ol>
        <h3>Magic Square</h3>
        <p>
        	A magic square is a square made of individual rows and columns. Each row and column is further divided into cells. So a magic square with 3 rows and 3 columns (represented as a 3x3 magic square) has 9 cells. Each cell, further, is filled with consecutive numbers. A 3x3 magic square hence has 9 consecutive numbers. The numbers in a magic square are there because they satisfy a special property. That property is:
        	<blockquote>
        		The numbers in each row, column or diagonal add up to the same value.
        	</blockquote>
        	Hence in this problem, we have to find these numbers. So, let's begin with assuming the following initial state for the square, with x<sub>1</sub>...x<sub>9</sub> representing the different numbers forming the magic square.
			<div style="display: inline-block; width: 100%">
				<br><div class="text_center"><strong>Initial State</strong></div>
				<br>
				<table class="state_box">
					<tr>
						<td>x<sub>1</sub></td>
						<td>x<sub>2</sub></td>
						<td>x<sub>3</sub></td>
					</tr>
					<tr>
						<td>x<sub>4</sub></td>
						<td>x<sub>5</sub></td>
						<td>x<sub>6</sub></td>
					</tr>
					<tr>
						<td>x<sub>7</sub></td>
						<td>x<sub>8</sub></td>
						<td>x<sub>9</sub></td>
					</tr>
				</table>
			</div>
			<br><br>
			So how do we solve it? Let's start!
			<strong>Algorithm</strong>
			<ol>
				<li>
					<span class="underline">Step 1</span>: Find the sum of numbers in each row/column/diagonal, using the following formula:
					<div class="text_center">
						<strong>
							<br>
							Sum of Numbers Used
							<br>
							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;----------------------    =  45/3  = 15
							<br>
							Number of rows/columns
						</strong>
					</div>
				</li>
				<br>
				<li>
					<span class="underline">Step 2</span>: Using the sum we obtained in the step above and the initial state, we can form the following equations:
					<br><br>
					<div class="text_center">
						<strong>
							x<sub>1</sub> + x<sub>2</sub> + x<sub>3</sub> = 15   --- (1)<br>
							x<sub>4</sub> + x<sub>5</sub> + x<sub>6</sub> = 15   --- (2)<br>
							x<sub>7</sub> + x<sub>8</sub> + x<sub>9</sub> = 15   --- (3)<br>
							x<sub>1</sub> + x<sub>4</sub> + x<sub>7</sub> = 15   --- (4)<br>
							x<sub>2</sub> + x<sub>5</sub> + x<sub>8</sub> = 15   --- (5)<br>
							x<sub>3</sub> + x<sub>6</sub> + x<sub>9</sub> = 15   --- (6)<br>
							x<sub>1</sub> + x<sub>5</sub> + x<sub>9</sub> = 15   --- (7)<br>
							x<sub>3</sub> + x<sub>5</sub> + x<sub>7</sub> = 15   --- (8)
						</strong>
					</div>
				</li>
				<br>
				<li>
					<span class="underline">Step 3</span>: Adding <strong>(5), (7) and (8)</strong>,
					<br>
					<br>
					<div class="text_center">
						<strong>
							x<sub>1</sub> + x<sub>2</sub> + x<sub>3</sub> + x<sub>5</sub> + x<sub>5</sub> + x<sub>5</sub> + x<sub>7</sub> + x<sub>8</sub> + x<sub>9</sub> = 15 + 15 + 15
							<br><br>
							x<sub>1</sub> + x<sub>2</sub> + x<sub>3</sub> + 3x<sub>5</sub> + x<sub>7</sub> + x<sub>8</sub> + x<sub>9</sub> = 45
						</strong>
						<br><br>
						Putting the values for <strong>x<sub>1</sub> + x<sub>2</sub> + x<sub>3</sub></strong> from eq. (1) and for <strong>x<sub>7</sub> + x<sub>8</sub> + x<sub>9</sub></strong> from eq. (3),
						<br><br>
						<strong>
							15 + 3x<sub>5</sub> + 15 = 45
							<br><br>
							x<sub>5</sub> = 5
						</strong>
					</div>
				</li>
				<br>
				<li>
					<span class="underline">Step 4</span>: Putting the value of <strong>x<sub>5</sub></strong> in every equation it appears,
					<br><br>
					<div class="text_center">
						<strong>
							x<sub>4</sub> + x<sub>6</sub> = 10   --- (2)<br>
							x<sub>2</sub> + x<sub>8</sub> = 10   --- (5)<br>
							x<sub>1</sub> + x<sub>9</sub> = 10   --- (7)<br>
							x<sub>3</sub> + x<sub>7</sub> = 10   --- (8)
						</strong>
					</div>
				</li>
				<br>
				<li>
					<span class="underline">Step 5</span>: Assuming <strong>x<sub>2</sub> = 1</strong> and <strong>x<sub>8</sub> = 9</strong> (and since we already know the value of <strong>x<sub>5</sub> = 5</strong>), we get
					<br><br>
					<div style="display: inline-block; width: 100%">
						<table class="state_box">
							<tr>
								<td>x<sub>1</sub></td>
								<td>1</td>
								<td>x<sub>3</sub></td>
							</tr>
							<tr>
								<td>x<sub>4</sub></td>
								<td>5</td>
								<td>x<sub>6</sub></td>
							</tr>
							<tr>
								<td>x<sub>7</sub></td>
								<td>9</td>
								<td>x<sub>9</sub></td>
							</tr>
						</table>
					</div>
					<br>
					Putting the values for <strong>x<sub>2</sub> = 1</strong>, <strong>x<sub>8</sub> = 9</strong> and <strong>x<sub>5</sub> = 5</strong> in the equations we have, we have
					<br><br>
					<div class="text_center">
						<strong>
							x<sub>1</sub> + x<sub>3</sub> = 14   --- (1)<br>
							x<sub>4</sub> + x<sub>6</sub> = 10   --- (2)<br>
							x<sub>7</sub> + x<sub>9</sub> = 6   --- (3)<br>
							x<sub>1</sub> + x<sub>4</sub> + x<sub>7</sub> = 15   --- (4)<br>
							x<sub>3</sub> + x<sub>6</sub> + x<sub>9</sub> = 15   --- (6)<br>
							x<sub>1</sub> + x<sub>9</sub> = 10   --- (7)<br>
							x<sub>3</sub> + x<sub>7</sub> = 10   --- (8)
						</strong>
					</div>
					<br>
					In a similar fashion we can continue assuming values for our remaining variables and keep checking whether our assumptions satisfy the above given equations. If they do, we continue with our assumptions. Else we change our assumptions.
					<br>
					Hence we can continue with the following assumptions, which satisfy the above equations, thus producing the 3x3 magic square as given below.
					<div style="display: inline-block; width: 100%">
						<table class="state_box">
							<tr>
								<td>8</td>
								<td>1</td>
								<td>6</td>
							</tr>
							<tr>
								<td>3</td>
								<td>5</td>
								<td>7</td>
							</tr>
							<tr>
								<td>4</td>
								<td>9</td>
								<td>2</td>
							</tr>
						</table>
					</div>
				</li>
			</ol>
        </p>
        <br>
        <h3>AI Problem Characteristics</h3>
        <ol>
            <li>
                <span class="underline">Decomposable Problem</span>: Is the problem <strong>decomposable</strong> into smaller sub-problems?
                <br>
                Some problems can be broken down into smaller sub-problems, which are individually easier to solve and the solution of the larger problem can be obtained by joining the solutions of these smaller sub-problems.
                <br>
                For eg. integrals are solved in parts and then individual solutions are combined for the complete solution.
            </li>
            <li>
                <span class="underline">Recoverable Problem</span>: Is <strong>backtracking</strong> possible?
                <br>
                In recoverable problems, we can reverse the application of an operator if required, and on the initial state another operator can be applied to obtain another desirable state.
                <br>
                For eg. 8-Puzzle problem is a recoverable problem while Chess is not.
            </li>
            <li>
                <span class="underline">Predicatble Problem</span>: Is the problem's answer <strong>predictable</strong>?
                <br>
                In predicatble problems, outcome of a particular move can judged with definiteness.
                <br>
                For eg. The 8-Puzzle problem.
            </li>
            <li>
                <span class="underline">Is a good solution absolute or relative?</span>: Is a good solution to the problem <strong>obvious</strong>?
                <br>
                There are some problems where the occurance of any one solution is enough and there is no need to ensure the validity of this solution by finding the other solutions. On the other hand there are problems where all solutions need to be found out and tallied against each other so as to find out the most optimum solution.
                <br>
                For eg. as in Travelling Salesman Problem, finding only a single route isn't enough because it could or could not be the best route. Hence we need to find all of them and tally them against each other to find out the shortest route.
            </li>
            <li>
                <span class="underline">Is the desired solution a <strong>state or a path</strong>?</span>: Understanding with an example, in medical diagnosis, the solution isn't just limited to finding the correct medicine for the diagnosis, but is almost always a long and complicated process that requires a constant care and attention given to the patient along with the medical care.
                <br>
                However solutions to problems are sometimes only answers that are treated as a state, in contrast to the abpve scenario which is treated as a path.
            </li>
            <li>
                <span class="underline">Is more knowledge required to find the <strong>solution</strong> or is knowledge only important to constrain the <strong>search</strong>?</span>: Some problems require minimal knowledge necessary to find the solution.
                <br>
                For eg. Tic-Tac-Toe.
                <br>
                However in medical expert systems, the amount of knowledge required is huge. Hence such problems are called knowledge intensive problems.
            </li>
        </ol>
        <h3>Search Space Search Techniques</h3>
        <ol>
            <li>
                <span class="underline">Blind (Unguided or Uninformed) Search</span>: is performed when no additional knowledge regarding the other states in the state space is provided. Hence it is absolutely necessary that we look at the entire search space for the next state.
            </li>
            <li>
                <span class="underline">Heuristic (Guided or Informed) Search</span>: is performed when additional knowledge regarding the problem is provided to direct the search in a specific direction.
            </li>
        </ol>
        <h3>Blind Search Algorithms</h3>
        <hr>
        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
        <p style="display: inline-block; margin: 0 auto; text-align: center; color: orange;">For BFS, kindly refer to the notes for the accompanying diagrams.</p>
        <hr>
        <ol>
            <li>
                <span class="underline">Breadth-First Search (BFS)</span>: Elementaries for the BFS Search Algorithm are as below:
                <ol>
                    <li>State Space is represented in the form of a tree and solution can be obtained by traversing through the various nodes in the tree.</li>
                    <li>In BFS, for every node we traverse, the root node is expanded first and then all the successions of the root node and so on.</li>
                    <li>While traversing, all the nodes on one level are explored first before moving on to the next level.</li>
                    <li>The data structure used for implementing BFS is a Queue (FIFO).</li>
                </ol>
                <h4>Algorithm</h4>
                <ol>
                    <li>Create a variable called NODE_LIST and set it to the intial state.</li>
                    <li>Until the goal state is found or the NODE_LIST becomes empty, do the following:</li>
                    <ol>
                        <li>Remove the first element from the NODE_LIST and call it E. If th NODE_LIST is empty, exit.</li>
                        <li>For each E, do the following:</li>
                        <ol>
                            <li>Apply the rule to generate a new state.</li>
                            <li>If the new state is the goal state, return this state and quit.</li>
                            <li>Else, add this state to the end of the NODE_LIST.</li>
                        </ol>
                    </ol>
                </ol>
                <h4>Advantages of BFS</h4>
                <ol>
                    <li>In case of a problem where multiple solutions exist, BFS finds the minimal solution first, which requires the least number of steps to reach.</li>
                </ol>
                <h4>Disadvantages of BFS</h4>
                <ol>
                    <li>Although it's good for problems with multiple solutions, it's very inefficient for problems with a single solution as it explores all possible branches which may lead to spending a lot of unnecessary time for exploring all the paths.</li>
                    <li>Memory consumption is very large because nodes on all the various path emerging from a single root node are explored.</li>
                </ol>
            </li>
            <br>
            <li>
                <span class="underline">Depth-First Search (DFS)</span>: Elementaries for the DFS Search Algorithm are as below:
                <ol>
                    <li>DFS always expands the deepest node in the current fringe of the search tree.</li>
                    <li>It explores the left most successor root node and expands it until a dead end is reached. In that case, the algorithm goes back to the next shallowest node with unexplored successors.</li>
                    <li>The data structure used for implementing DFS is a stack (LIFO).</li>
                </ol>
                <h4>Algorithm</h4>
                <ol>
                    <li>If the intial state is the goal state, return and quit.</li>
                    <li>Else, do the following until success or failure:</li>
                    <ol>
                        <li>Generate successor E of the intial state. If no more successors, then report failure.</li>
                        <li>Call DFS with E as the intial state.</li>
                        <li>If success is reported, return the state. Else continue exploring.</li>
                    </ol>
                </ol>
                <h4>Advantages of DFS</h4>
                <ol>
                    <li>It requires less memory because nodes only on a single path are explored first before exploring other paths.</li>
                    <li>In case of a problem where only a single solution exists, DFS may find the solution relatively easily without exploring much of the search space.</li>
                </ol>
                <h4>Disadvantages of DFS</h4>
                <ol>
                    <li>Finding a solution using DFS in a problem where there might be more than one solution does not guarantee that the solution found is the most efficient one.</li>
                    <li>DFS may follow a single unfruitful path for a very long time without having a larger idea of the problem.</li>
                </ol>
            </li>
        </ol>
        <h3>Heuristic Search</h3>
        <ol>
            <li>Heuristics is nothing but an <strong>informed guess</strong> of the next step to be taken in attempting the solution of the problem.</li>
            <li>It might not always find the best solution, but is guaranteed to find a <strong>good solution in a reasonable time</strong>. Hence it is useful in solving tough problems which couldn't be solved in any other way or where the process to find a solution may take an infinitely long time, using the traditional methods.</li>
            <li>In heuristic search, unlike normal searching techniques, besides normal production rules, some additional information or knowledge about the problem is given in form of a mathematical function called the heuristic function. Because of the presence of this extra information, heuristic search is also called <strong>informed/ guided search</strong>.</li>
        </ol>
        Heuristic Search can be applied in the following scenarios:
        <ol>
            <li>
                <strong>When the problem does not have an exact solution because of the inherent ambiguities in the problem statement or the data available.</strong>
                <br>
                For eg. In medical diagnosis, if there are several symptoms indicated by the patient pointing towards different diseases, a heuristic technique is adopted so as to find the most likely disease. 
            </li>
            <li>
                <strong>When a problem is having a solution but the cost of finding that solution is unbearable.</strong>
                <br>
                For eg. In chess as the no. of possible states are huge, BFS and DFS techniques are inefficient in finding a solution in an acceptable time limit. Hence heuristic search techniques are used to handle problems like these by guiding the search and eliminating un-promising states from the state space.
            </li>
        </ol>
        <h3>Heuristic Search Algorithms</h3>
        <hr>
        <h2 class="part_not_understood">THE SOLUTION OF THIS PROBLEM IS EITHER NOT COMPLETE OR NOT FULLY UNDERSTOOD</h2>
        <h4 class="part_not_understood">Understand 8-Puzzle Problem solved using Hill Climbing Search Algorithm</h4>
        <hr>
        <hr>
        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
        <p style="display: inline-block; margin: 0 auto; text-align: center; color: orange;">Refer to the notes for diagrammatic representations of the "Limitations of Hill Climbing Search"</p>
        <hr>
        <ol>
            <li>
            	<span class="underline">Generate and Test</span>: This is a very simple heuristic search approach where first a result is generated and then tested whether it is the desired solution or not.
            	<br><br>
            	<strong>Algorithm</strong>
            	<br><br>
            	<ol>
            		<li>Generate a possible solution to the problem. It can either be a point in the problem space or a path from the initial state.</li>
            		<li>Test this solution against the goal state to see if it is the desired solution.</li>
            		<li>If the obtained solution matches against the goal state, exit. Otherwise repeat from 1.</li>
            	</ol>
            	<br>
            	Hence there are 2 ways we can carry forward a Generate and Test search:
            	<ol>
            		<li>Generate a random solution and test. If found wrong, generate another random solution and test. Hence in this way it might be possible that the very first generated solution gets matched with the goal state.</li>
            		<li>Adopt a systematic approach towards generating and testing solutions. It might take a lot of time and certainly requires a large problem space.</li>
            	</ol>
            	<br>
            	<strong>Generate and Test</strong> is overall good for simple problems only and not accpetable for problems with a large problem space.
            </li>
            <br>
            <li>
            	<span class="underline">Best First Search</span>: is a combination of BFS and DFS. How?
            	<blockquote>
            		<strong>BFS</strong>: As in BFS, there is no chance of getting trapped on a dead end path.
            		<br>
            		<strong>DFS</strong>: As in DFS, all branches neeed not be expanded in order to get the solution. 
            	</blockquote>
            	By combining these two techniques, Best First Search follows only a single path an any time, switching paths in between intelligently whenever another path looks more promising than the current one. But how's the better path decided amongst two or more competing paths?
            	<blockquote>
            		Every node in the problem graph upon which Best First Search is being applied, is associated with an evaluation function. The value of the evaluation function depends upon the distance of the current node from the root node. Hence only the most promising route is traversed in Best First Search, with the value of the evaluation function helping to decide the best route amongst a number of candidate routes. This may also be called as Greedy Best First Search.
            	</blockquote>
            	In Best First Search, two lists are required for operation:
            	<ol>
            		<li><span class="underline">OPEN</span>: Nodes discovered but not yet expanded for child nodes</li>
            		<li><span class="underline">CLOSED</span>: Nodes discovered and successfully expanded for child nodes</li>
            	</ol>
            	<br>
            	<strong>Algorithm</strong>
            	<br>
            	<ol>
            		<li>Put the initial node into the OPEN list</li>
            		<li>If OPEN = EMPTY or OPEN = GOAL, exit. Else, remove the first node from OPEN (say A).</li>
            		<li>If A = GOAL, exit. Else generate all child nodes of A, add A to CLOSED list and it's child nodes to OPEN list, in the order of their value of their respective evaluation function values.</li>
            		<li>Go back to step 2.</li>
            	</ol>
            </li>
            <br>
            <li>
            	<span class="underline">A* or Optimal Search</span>
            	<hr>
		        <h2 class="part_not_understood">THE SOLUTION OF THIS PROBLEM IS EITHER NOT COMPLETE OR NOT FULLY UNDERSTOOD</h2>
		        <h4 class="part_not_understood">Understand the state-space representation & general working of A* Algorithm on Tower of Hanoi problem</h4>
		        <hr>
            	The A* Algorithm is a specialisation of the Best First Search Algorithm, the only difference being that in this case, the evaluation function is of the form as given below:
            	<blockquote>
            		f(n) = g(n) + h(n)
            		<br>
            		where
            		<br>
            		<strong>g(n)</strong>: gives the path cost from the start node to node <strong>n</strong>
            		<br>
            		<strong>h(n)</strong>: is the estimated cost of the cheapest path from node <strong>n</strong> to the goal node
            		<br>
            		<strong>f(n)</strong>: summation of g(n) and h(n). It gives the estimated cost of the cheapest path from start node to goal node passing through <strong>n</strong>
            	</blockquote>
            	The A* Search Algorithm is both optimal and complete only if the algorithm never over-estimates the path cost between two particular nodes (admissible heuristics).
            	<br>
            	A* Search Algorithm uses OR-Graph to find the solution of the problem.
            	<br>
            	<br>
            	<strong>A* Search Algorithm</strong>
            	<ol>
            		<li>Place the starting node in the OPEN list.</li>
            		<blockquote>
            			For reference, to what is OPEN and CLOSE lists, refer to their description in Best First Search.
            		</blockquote>
            		<li>If the OPEN list is empty, stop and return failure. Else remove from OPEN list the node <strong>n</strong> with the lowest value of f(n). If that node is the goal node, return success and exit.</li>
            		<li>Expand <strong>n</strong> by generating all of it's successors and put <strong>n</strong> in the CLOSED list.</li>
            		<li>For every node, whether be <strong>n</strong> or it's successors, check if it's already in the CLOSED list or if there's a node with an equal or lower cost estimate already available. If so, we can safely disregard <strong>n</strong>, or it's successors and move on.</li>
            		<li>If there's no better version of <strong>n</strong> found either on the OPEN or CLOSED lists, then remove all the inferior copies from those lists as <strong>n</strong> is superior to them all.</li>
            		<li>Add this least cost node at the beginning of the OPEN list and return to the beginning of the loop, right at the start of the OPEN list.</li>
            	</ol>
            </li>
            <br>
            <li>
            	<span class="underline">Problem Reduction</span>
            	<hr>
		        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
		        <p style="display: block; text-align: center; color: orange;">Refer to the notes for the AND-OR Graph best path determination</p>
		        <hr>
            	Sometimes problems can be solved in a better manner using a process called decomposition or problem reduction method. In this method problems can be solved by decomposing them into a set of smaller problems and intelligently determining in which order to solve them so that we finally incur the least cost.
            	<br>
            	We use AND-OR graphs here, unlike in Best First Search(A* Search) where we use OR-Graphs, because here the choice of which node is to be expanded depends not only on it's <strong>f</strong> value, but also whether that node is part of the best (least cost) path.
            	<br>
            	<br>
            	<strong><span id="futility">Futility</span></strong>: The term futility refers to the cost value above which a solution path is considered to be too expensive to be practical.
            	<br><br>
            	We use the concept of problem reduction to devise another heuristic search algorithm, with the name of AO*. It'd be wise to study AO* Search Algorithm while we are discussing Problem Reduction, as given below.
            	<br><br>
            	<strong>AO* Algorithm</strong>
            	<ol>
            		<li>It uses AND-OR graph for problem reduction.</li>
            		<li>It generates a GRAPH from a larger search graph comprising of all the nodes in the search space.</li>
            		<li>During the GRAPH generation, it traverses nodes and marks them either SOLVED or UNSOLVED. The problem is assumed to be solved when the start node is marked SOLVED.</li>
            	</ol>
            	<br>
            	<strong>Algorithm</strong>
            	<br>
            	<br>
            	<span class="underline">Terminology</span>: Please understand the following terms which will be used in the algorithm:
            	<ol>
            		<li>
            			<em>GRAPH</em>: The search graph yet traversed and generated.
            		</li>
            		<li>
            			<em>INIT</em>: The source node you start your algorithm with. 
            		</li>
            		<li>
            			<em>FUTILITY</em>: <a href="#futility"><strong>Click here</strong></a>
            		</li>
            		<li>
            			<em>NODE</em>: The immediate child of INIT.
            		</li>
            		<li>
            			<em>SUCCESSOR</em>: Immediate child of NODE.
            		</li>
            		<li>
            			<em>CURRENT</em>: A particular node amongst all the SUCCESSORS.
            		</li>
            		<li>
            			<em>SOLVED</em>: A node that has been fully explored and there exists a minimum cost path h(n) for the SOLVED node n.
            		</li>
            	</ol>
            	<br>
            	Coming to the actual algorithm,
            	<ol>
            		<li>In the beginning, let GRAPH consist of only the initial state, INIT. Compute h(INIT).</li>
            		<li>Until INIT is marked SOLVED or h(INIT) > FUTILITY, repeat the following steps:</li>
      				<ol>
      					<li>Generate the successors of INIT. Call one of them NODE, to be further operated upon.</li>
      					<li>
      						Generate the child nodes of NODE and depending upon the outcome, perfome the following steps:
      						<ol>
      							<li>If no child nodes exist, mark h(NODE) as FUTILITY, equivalent to saying that NODE is unsolvable.</li>
      							<li>
      								If child nodes exist, further referring to them as SUCCESSORS, perform the following:
      								<ol>
      									<li>Add SUCCESSOR to GRAPH</li>
      									<li>If SUCCESSOR is a terminal (leaf) node, mark it as SOLVED and assign h(SUCCESSOR) = 0.</li>
      									<li>Else compute h(SUCCESSOR).</li>
      								</ol>
      							</li>
      						</ol>
      					</li>
      					<li>
      						Now since new child nodes have been traversed and added to the GRAPH, h (cost) values for the parent nodes need to be changed. Let S denote all the SOLVED nodes in the GRAPH. Hence until S is empty, perform the following steps:
      						<ol>
      							<li>Select a node from S. Call it CURRENT.</li>
      							<li>
      								Expand CURRENT until all it's child nodes are known. Now compute the h values along all of these child nodes and assign the CURRENT's h value as the minimum of these examined nodes' h values. The costs are determined as following:
      								<blockquote>
      									cost of the arc + h value of the node at the end of the arc
      								</blockquote>
      							</li>
      							<li>Mark the best path out of CURRENT along the arcs which lead to the path with the minimum cost (min. h value).</li>
      							<li>Mark CURRENT as SOLVED if all of it's child nodes and their subsequent exapnsions have been marked as SOLVED. Also, if CURRENT gets marked as SOLVED or gets changed in value, propagate this changed value back to all the ancestor nodes of CURRENT.</li>
      						</ol> 
      					</li>
      				</ol>
            	</ol>
            </li>
            <br>
            <li>
            	<span class="underline">Constraint Satisfaction</span>: Constraint Satisfaction is a problem solving method applicable to those categories of of problems where a goal state is not specified. These problems are defined using a set of variables (x<sub>1</sub>, x<sub>2</sub>...x<sub>n</sub>) and a set of constraints (c<sub>1</sub>, c<sub>2</sub>...c<sub>n</sub>). Further each variable x<sub>i</sub> is assigned a value v<sub>i</sub>. The general problem is to find a solution that satisfies the given set of constraints.
            	<br>
            	Graph Problems are one such example of these type of problems.
            	<br><br>
            	<strong>Algorithm</strong>
            	<ol>
            		<li>Set OPEN to all the variables that must be assigned a value for the solution to be complete.</li>
            		<li>
            			Repeat the following until inconsistency (lack of a solution) is found or all the variables get a value
            			<ol>
            				<li>Select a variable from OPEN and apply the respective set of constraints to that variable.</li>
            				<li>If these constraints being applied are any different to the ones that have already been applied, add to OPEN other variables too that share the same constraints.</li>
            				<li>After application of constraints is complete, remove this (or these) variables from OPEN.</li>
            				<li>Following these steps, one of the possible events might take place:
	            				<ol>
	            					<li>If a solution is hence found, return the solution and quit.</li>
	            					<li>If a contradiction to the variables and their values is found, as a result of the application of its constraints, return failure and quit.</li>
	            					<li>If none of the above mentioned activities happen, keep repeating until a solution is found or all possible solutions are exhausted. Strengthen the constraints of those variables without a value and recursively invoke constraint satisfaction.</li>
	            				</ol>
            				</li>
            			</ol>
            		</li>
            	</ol>
            	<br>
            	<strong>Types of Constraints</strong>
            	<ol>
            		<li>
            			<span class="underline">Unary Constraints</span>: are those which apply on only one variable.
            			<br>
            			For eg. Indians like spicy food. Here the food (which is spicy) is a constraint applied to the variable in the sentence, Indians.
            		</li>
            		<li>
            			<span class="underline">Binary Constraints</span>: are those which apply on two variables.
            			<br>
            			For eg. India is militarically stronger than Pakistan. Here the constraint stronger (militarically) applies on two variables: India and Pakistan.
            		</li>
            		<li>
            			<span class="underline">Higher Order Constraints</span>: are those that apply to three or more variables. 
            		</li>
            	</ol>
            	<br>
            	<strong>Cryptarithmetic Problems</strong>
            	<br>
            	See, these problems are more hit-and-try than anything methodical. So please refer to the video tutorials linked below, and see any of the solved examples in the notes. However while solving, keep the following rules in mind:
            	<ol>
            		<li>There are letters involved. A-Z. They may appear more than once in a problem.</li>
            		<li>These letters form up words together. These words are just representations for actual numbers that are being operated upon.</li>
            		<li>The numbers these letters (together forming words) are distinct from one another, unlike the alphabets. So always keep this in mind that one alphabet can have one and only one value in a given problem.</li>
            		<li>The carry number that comes out of any additive numeric operation can only be a 1. Why? Because all alphabets are distinct; the maximum numbers that can add up to produce a carry are 9 and 8, which when added give 17, hence 1 as carry.</li>
            	</ol>
            	<br>
            	To learn more, refer these videos:
            	<br>
            	<br>
            	<br>
	            <div class="text_center">
	            	<strong>Constraint Satisfaction Tutorial</strong>
	            	<br>
	            	<iframe width="100%" height="56.5%" src="https://www.youtube.com/embed/lCrHYT_EhDs" frameborder="0" allowfullscreen></iframe>
	            	<br>
	            	<br>
	            	<strong>Cryptarithmetic Problems</strong>
	            	<br>
	            	<iframe width="100%" height="56.5%" src="https://www.youtube.com/embed/lbT5qMHMtJ0" frameborder="0" allowfullscreen></iframe>
	            </div>
            	<br>
            	<br>
            </li>
            <br>
            <li>
            	<span class="underline">Branch & Bound Search Technique</span>: applies to problems having a graph search space where more than one alternate path exists between two nodes.
            	<br>
            	For eg. Travelling Salesman Problem.
            	<br><br>
            	The technique generates a new path in each iteration, while keeping track of the best path traversed as yet. If a branch offers a minimal cost path to the goal state, it is stored as a bound and treated as part of the best path and it's extensions are generated for advancement of the search. Else it (and it's extensions) is discarded.
            	<br>
            	<br>
            	<strong>Algorithm</strong>
            	<br>
            	<ol>
            		<li>Enqueue the start node.</li>
            		<li>
            			Repeat the following steps until the queue gets empty or the goal state is reached:
            			<ol>
            				<li>Check if the first node in the queue is the goal node.</li>
            				<li>If it's a goal node, then report success and exit. Else dequeue it and enqueue it's child nodes.</li>
            				<li>Compute the cost of the new paths and sort them in the queue.</li>
            			</ol>
            		</li>
            		<li>Otherwise exit with failure.</li>
            		</li>
            	</ol>
            </li>
            <br>
            <li>
                <span class="underline">Hill Climbing Search</span>: This technique uses feedback from the test procedure in deciding in which direction the search should proceeed. It is useful for solving a problem where knowledge of path is not important and hence no search tree is required. This technique only a current state and an objective function to determine it's path.
                <h4>Algorithm</h4>
                <ol>
                    <li>
                        Evaluate the intial state.
                        <ol>
                            <li>If it's the goal state, return and quit.</li>
                            <li>Else continue with the initial state as the current state.</li>
                        </ol>
                    </li>
                    <li>
                        Loop through the following instructions until the goal state is found or there are no new operators left to be applied to the current state
                        <ol>
                            <li>Select an operator that has not been yet applied to the current state and apply it to produce a new state</li>
                            <li>
                                Evaluate the new state
                                <ol>
                                    <li>If it is the goal state, then return and quit</li>
                                    <li>If it is not the goal state but is better than the current state, then make it the current state</li>
                                    <li>If it is not the goal state and neither better than the current state, then continue in the loop.</li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                </ol>
                <h4>Limitations</h4>
                <ol>
                    <li>
                        <span class="underline">Local Maxima</span>: A local maxima is a peak which is although better than the current state, but ultimately lower than the global peak of the state space. The problem with hill climbing algorithm is that if the searching finds a local maxima, it halts thinking this is the best solution available even though there is a better solution available (global peak) in the state space. 
                    </li>
                    <li>
                        <span class="underline">Plateau</span>: A plateau is a flat area of the search space where the next move does not give a better solution than the present state. Hence it becomes difficult to decide where to move.
                    </li>
                    <li>
                        <span class="underline">Ridge</span>: A ridge can have steeply sloping sids so that the search reaches the top with ease. But while near the top, it may slope gently near the peak. Unless there happens to be operators that move directly to the top of the ridge, there might be no change in the heuristic function for a long time and the search could halt after a few iterations.
                    </li>
                </ol>
            </li>
            <br>
            <li>
                <span class="underline">Mean End Analysis</span>: This technique uses a bidirectional search technique.
                <br><br>
                <ol>
                    <li>
                        <span class="underline">Forward Search</span>: starts from the initial state to the goal state. 
                    </li>
                    <li>
                        <span class="underline">Backward Search</span>: starts from the goal state to the initial state. 
                    </li>
                </ol>
                <br>
                Hence this technique solves the problem in parts and finds the final solution by combining these individual solutions.
                <br>
                A special data structure is used to maintain the difference between the current state and the goal state, called the difference table.
                <br>
                MEA relies on a set of rules to transform one problem state into another. These rule types are as below
                <ol>
                    <li>
                        <span class="underline">Pre-Conditions</span>: Conditions that must be met for the rule to be applicable.
                    </li>
                    <li>
                        <span class="underline">Post-Condition</span>: Result obtained on application of the rule.
                    </li>
                </ol>
            </li>
        </ol>
        <br>
        <h2 id="Module2">Module 2: Knowledge Representation</h2>
        <br>
        <h3>Why Knowledge Representation?</h3>
        AI is used to build efficient and economical <em>expert systems</em> that help solve real world problems. These expert systems require huge amounts of knowledge to respond with human-like intelligence. Hence effective, simple but powerful means of knowledge representation is required for the fullfillment of this purpose.
        <h3>What is knowledge?</h3>
        <hr>
        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
        <p style="display: block; margin: 0 auto; text-align: center; color: orange;">Please refer to the diagram representing the <strong>mapping between facts and representations</strong></p>
        <hr>
        <ol>
        	<li>
        		Knowledge is an organized form of data. It can be used for useful purposes.
        		<br>
        		For eg. when a doctor treats a patient, he uses both the data and knowledge in diagnosis. Data comes from the patient's reports while knowledge comes from the doctor's experience.
        	</li>
        	<li>
        		It consists of
        		<ol>
        			<li>Facts</li>
        			<li>Assumptions</li>
        			<li>Heuristics (Intelligent Guesses)</li>
        		</ol>
        	</li>
        	<li>
        		Different problems require different types of knowledge and hence different knowledge representation  techniques exist. A few common ones are as following:
        		<ol>
        			<li>
        				<strong>"Spot is a Dog"</strong> can be represented as <strong>"dog(spot)"</strong>
        				<br>
        				It is worthwhile to notice that the entity <strong>outside</strong> the brackets is the <em>class</em> while the entity <strong>inside</strong> the brackets is the <em>object</em>.
        			</li>
        			<li>
        				<strong>"Every dog has a tail"</strong> can be represented as <strong>&forall;x : dog(x) -> hastail(x)</strong>
        				<br>
        				Which can be further deduced using (1) as
        				<br>
        				hastail(Spot), meaning <strong>"Spot has a tail"</strong>
        			</li>
        		</ol>
        	</li>
        </ol>
        <h3>Things to consider while Knowledge Representation?</h3>
        <ol>
        	<li>Attributes of objects (like Spot was an object we took as an example above)</li>
        	<li>Relationship amongst attributes</li>
        	<li><span class="underline">Granularity (Depth) of representation</span>: (Affects the size of the knowledge base)</li>
        	<li><span class="underline">Inferencing Mechanism used</span>: An Inferencing Mechanism is used to find the solution of a problem using the knowledge base</li>
        </ol>
        <h3>Properties of Knowledge Representation Systems</h3>
        <ol>
        	<li>
        		<span class="underline">Representational Adequacy</span>: The abillity of the Knowledge Representation System to represent all kinds of knowledge, as needed.
        	</li>
        	<li>
        		<span class="underline">Inferential Adequacy</span>: The abillity of the knowledge representational system to derive new knowledge from the existing, old knowledge structures.
        	</li>
        	<li>
        		<span class="underline">Inferential Efficiency</span>: The abillity to incorporate additional information that can be used to direct the knowledge inference mechanism in the most promising direction.
        	</li>
        	<li>
        		<span class="underline">Acquisitional Efficiency</span>: The abillity to acquire new information using automatic mechanisms without requiring any human intervention.
        	</li>
        </ol>
        <h3>Types of Knowledge?</h3>
        <hr>
        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
        <p style="display: block; margin: 0 auto; text-align: center; color: orange;">Please refer to the diagrams for the respective knowledge types</p>
        <hr>
        <ol>
        	<li>
        		<span class="underline">Relational Knowledge</span>: In this type of knowledge facts are represented as set of relations in a tabular form. The table is composed of attributes and tuples, where tuples are the values the object has for a particular attribute it possesses.
        		<br>
        		This form of knowledge is very simple and doesn't provide much inferential capabilities.
        	</li>
        	<li>
        		<span class="underline">Inheritable Knowledge</span>: In real world, knowledge might not be like a separate entity as in Relational Knowledge. Instead knowledge may exist in form of inhertable relationships between entities. This forms the basis of Inheritable Knowledge.
        	</li>
        	<li>
        		<span class="underline">Inferential Knowledge</span>: A knowledge representation method which can use inference mechanism to use and expand it's knowledge base is called inferential knowledge.
        	</li>
        	<li>
        		<span class="underline">Procedural Knowledge</span>: refers to conditional knowledge. It specifies <em>when</em> what is to be done.
        		<br>
        		For eg.
        		<blockquote>
        			<strong>IF:</strong>
        			<br>
        			A student has deposited fees,
        			<br>
        			The student has opted for a course
        			<br>
        			The student has attended 90% classes
        			<br>
        			The student has passed the examination
        			<br>
        			<strong>THEN</strong>:
        			<br>
        			Delare the student pass.
        		</blockquote>
        	</li>
        	<li>
        		<span class="underline">Declarative Knowledge</span>: refers to factual knowledge. Again facts can be of two types:
        		<ol>
        			<li>
        				<span class="underline">Static Facts</span>: which do not change with time. Like my gender.
        			</li>
        			<li>
        				<span class="underline">Dynamic Facts</span>: change with time. Like my height.
        			</li>
        		</ol>
        	</li>
        	<li>
        		<span class="underline">Heuristic Knowledge</span>: Judgemental knowledge which differs from individual to individual. It refers to the abillity of a person to make informed and educated guesses.
        		<br>
        		For eg. asking a person which team would win in a fair competition. 
        	</li>
        	<li>
        		<span class="underline">Common Knowledge</span>: Domain independent knowledge, general in nature, attained by experience.
        	</li>
        	<li>
        		<span class="underline">Explicit Knowledge</span>: Knowledge that can be easily expressed in mathematical terms and is held in an individual's conscience. This form of knowledge is communicable, universal and can be processed, stored and transferred electronically.
        	</li>
        	<li>
        		<span class="underline">Uncertain Knowledge</span>: Most of the real world phenomena is uncertain. It refers to knowledge that we can provide to the best of our abillity but is never complete or deterministic.
        		<br>
        		For eg. weather forcasts might show that it'll rain today but we cannot determine it's occurance to the exact minute.
        	</li>
        </ol>
        <h3>Logic?</h3>
        Logic is a language used to express knowledge, facts and their interaction. It's used for designing of the knowledge base in AI.
        <br>
        Some elementary knowledge representational techniques are:
        <ol>
        	<li>Representation in Propositional Logic</li>
        	<li>Representation in Predicate Logic</li>
        	<li>Representation in Conceptual Dependency Structures</li>
        </ol>
        However logic itself can be of two types in AI:
        <ol>
        	<li>Propositional Logic or Propositional Calculus</li>
        	<li>Predicate Logic or Predicate Calculus</li>
        </ol>
        <h3>Propositional Logic/ Propositional Calculus?</h3>
        A proposition is any declarative sentence that we say in our day-to-day life which is either TRUE or FALSE.
        <br>
        <strong>Propositional Logic/ Propositional Calculus</strong> is a language to represent propositions using well defined symbols.
        <blockquote>
        	New Delhi is capital of India. -> Valid proposition, as it's TRUE
        	<br>
        	India will be a superpower by 2020. -> Valid proposition, as it'll be either TRUE or FALSE, but not both
        	<br>
        	No, thank you. -> Invalid proposition, as it's an assertion
        </blockquote>
        Propositions are of 2 types:
        <ol>
        	<li>
        		<span class="underline">Atomic Proposition</span>: is made of a single proposition.
        		<br>
        		For eg. Sachin Tendulkar was a cricketer.
        	</li>
        	<li>
        		<span class="underline">Molecular Proposition</span>: is a combination of two or more propositions.
        		<br>
        		For eg. Sachin Tendulkar is a cricketer and Miranda Kerr is a model.
        	</li>
        </ol>
        There are 3 Syntactical Elements of Propositional Logic:
        <ol>
        	<li>
        		<span class="underline">Vocabulary</span>: Set of propositional symbols (Literals, Eg. P, Q, R, etc. where P might represent "It is hot") which represent valid propositions and can either be TRUE or FALSE.
        	</li>
        	<li>
        		<span class="underline">Logical Connectives/ Operators</span>: There are 6 logical operators:
        		<ol>
        			<li>
        				<span class="underline">&and; (AND/ Conjunction)</span>: P&and;Q will be TRUE if both A and B are TRUE. Conjuntcion of two or more sentences is also a sentence.
        			</li>
        			<li>
        				<span class="underline">&or; (OR/ Disjunction)</span>: P&or;Q will be TRUE if either P, or Q, or both are TRUE. Disjunction of two or more sentences is also a sentence.
        			</li>
        			<li>
        				<span class="underline">! or &sim; (NOT)</span>: If P is TRUE, &sim;P is FALSE, and vice versa. Also the negation of a literal or a sentence is a literal or a sentence.
        			</li>
        			<li>
        				<span class="underline">&rarr; (Implies/ IMPLICATION)</span>: P&rarr;Q means that if P is TRUE, the Q is also TRUE and vice versa.
        				<br>
        				P is called the Premise while Q is called the Conclusion.
        			</li>
        			<li>
        				<span class="underline">&harr; (If and Only If/ BI-CONDITIONAL)</span>: A biconditional statement, P&harr;Q holds only if P and Q both have same values.
        			</li>
        			<li>
        				<span clas="underline">&equiv; (EQUIVALENCE)</span>: A statement P&equiv;Q means that P and Q both hold the same logical values.
        			</li>
        		</ol>
        	</li>
        	<li>
        		<span class="underline">Values</span>: which can be either TRUE (T) or FALSE (F), called logical constants.
        	</li>
        </ol>
        Semantics, or meaning of a propositional statement is either TRUE or FALSE. The following truth table helps us understand how/ why a these values are assigned:
        <br><br>
        <table style="min-width: 60%;">
        	<tr>
        		<th>P</th>
        		<th>Q</th>
        		<th>&sim;P</th>
        		<th>P&and;Q</th>
        		<th>P&or;Q</th>
        		<th>P&rarr;Q</th>
        		<th>P&harr;Q</th>
        	</tr>
        	<tr>
        		<td>F</td>
        		<td>F</td>
        		<td>T</td>
        		<td>F</td>
        		<td>F</td>
        		<td>T</td>
        		<td>T</td>
        	</tr>
        	<tr>
        		<td>F</td>
        		<td>T</td>
        		<td>T</td>
        		<td>F</td>
        		<td>T</td>
        		<td>T</td>
        		<td>F</td>
        	</tr>
        	<tr>
        		<td>T</td>
        		<td>F</td>
        		<td>F</td>
        		<td>F</td>
        		<td>T</td>
        		<td>F</td>
        		<td>F</td>
        	</tr>
        	<tr>
        		<td>T</td>
        		<td>T</td>
        		<td>F</td>
        		<td>T</td>
        		<td>T</td>
        		<td>T</td>
        		<td>T</td>
        	</tr>
        </table>
        <br>
        A <strong>Well Formed Formula</strong> consists of atomic symbols joined with connectives.
        <ol>
        	<li>"P" is a WFF, since P is a propositional variable.</li>
        	<li>"&sim;P" is hence a WFF too.</li>
        	<li>Further if P and Q are WFFs, then (P&or;Q), (P&and;Q), (P&rarr;Q) and (P&harr;Q) are WFFs too.</li>
        </ol> 
        <strong>Laws of Propositional Logic</strong>
        <br>
        Refer to them from the notes. But a few of them are:
        <br>
        <br>
        <div class="text_center">
        	<img src="images/Laws_Page_1.jpg" alt="Laws of Propositional Logic" style="width: 75%; height: 100%; border: 5px solid black;">
        </div>
        <br>
        A statement in propositional logic/ propositional calculus can be:
        <ol>
        	<li>
        		<span class="underline">Valid</span>: A sentence is valid if it's TRUE for all inputs (TRUE or FALSE).
        		<br>
        		For eg. P&or;&sim;P is valid for every value of P.
        	</li>
        	<li>
        		<span class="underline">Satisfiable</span>: A proposition which is TRUE for at least one value.
        	</li>
        	<li>
        		<span class="underline">Unsatisfiable (Contradiction)</span>: A proposition which is never TRUE.
        		<br>
        		For eg. P&and;&sim;P is never TRUE for any given value of P.
        	</li>
        	<li>
        		<span class="underline">Equivalence</span>: Two statements are equivalent when they share the same logical value for every interpretation.
        		<br>
        		For eg. P and &sim;(&sim;P) are equivalent statements.
        	</li>
        	<li>
        		<span class="underline">Logical Consequence</span>: A statement S<sub>2</sub> is said to be a logical consequence of S<sub>1</sub> if it is satisfied by all interpretations which satisfy S<sub>1</sub>.
        	</li>
        </ol>
        <strong>Inferencing in Propositional Logic?</strong>
        <br>
        Inferencing in Propositional Logic refers to deriving new propositions from existing/ given propositions.
        <br>
        A Proposition that is assumed to be true is called as a <strong>premise/ hypothesis</strong> and a proposition that is derived using the <em>rules of inference</em> is called a <strong>conclusion</strong>.
        <br>
        Some <strong>(NOT ALL)</strong> of the rules of inference are as below:
        <br>
        <br>
        <div class="text_center">
        	<img src="images/slide_8.jpg" alt="Rules of Inference in Propositional Logic" style="width: 75%; height: 100%; border: 5px solid black;">
        </div>
        <br>
        <strong>Resolution Algorithm in Propositional Logic</strong>
        <hr>
        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
        <p style="display: block; margin: 0 auto; text-align: center; color: orange;">Please ensure that all the numerical examples are solved (Pages 134-135)</p>
        <hr>
        <ol>
        	<li>
        		Convert all assumed/ given propositions into Clausal Form (A special form of representation of propositions, where different literals have disjunctive relations between them), using the following steps:
        		<ol>
        			<li>
        				Eliminate &rarr; and &harr; using the following rules:
        				<blockquote>
        					<strong>P&rarr;Q</strong> can be simplified as <strong>&sim;P&or;Q</strong>
        					<br>
        					<strong>P&harr;Q</strong> can be simplified as <strong>(&sim;P&or;Q)&and;(&sim;Q&or;P)</strong>
        				</blockquote>
        			</li>
        			<li>
        				Reduce the number of &sim; using the following:
        				<blockquote>	
    						Either by cancelling &sim;s against each other, for eg. &sim;(&sim;P) = P
    						Or by using de Morgan's laws, for eg.
    						<br>
    						&sim;(A&and;B) &equiv; &sim;A &or; &sim;B
    						<br>
    						OR
    						<br>
    						&sim;(A&or;B) &equiv; &sim;A &and; &sim;B
    					</blockquote>
        			</li>
        			<li>Convert to Conjunctive Normal Form using the laws of propositional logic.</li>
        		</ol>
        	</li>
        	<li>The literal which is to be proved TRUE, assume it to be FALSE and add it to the set of clauses.</li>
        	<li>
        		Perform the following until a contradiction is found or no progress can be made (NULL value comes as a result):
        		<ol>
        			<li>Solve two clauses and call them parent</li>
        			<li>Resolve them together. The result is called as the Resolvent.</li>
        			<li>If the resolvent is an empty clause or a contradiction, exit. Else add the resolvent to the set of clauses.</li>
        		</ol>
        	</li>
        </ol>
        <strong>Limitations of Propositional Logic</strong>
        In Propositional logic, we have to declare a rule for each and every sentence, which is not a good approach.
        <br>
        For eg.
        <ol>
        	<li>
        		<blockquote>
        			All dogs are faithful  &mdash;> 1
        			<br>
        			Tommy is a dog  &mdash;> 2
        			<br>
        			Tommy is hence, faithful  &mdash;> 3
        		</blockquote>
        		Sure 1 is a proposition, as is 2 but 3 is in NO CASE an inference coming from 1 and 2. <strong>3  P&and;Q</strong>.
        	</li>
        	<li>
        		<blockquote>
        			P: Tom is a boy.
        		</blockquote>
        		But Jim is also a boy. Also we cannot represent Jim with P. Hence every different person will require to be having a different proposition, even though every proposition means the same thing (that a person X is a boy). Hence, it's not a good approach.
        	</li>
        </ol>
        <br>
        <h3>Predicate Logic/ Predicate Calculus/ First Order Predicate Logic (FOPL)</h3>
        Predicate Logic is a generalisation of Propositional Logic, a formal language to represent statements and their relationships as WFFs (Well Formed Formulae).
        <br>
        <br>
        <strong>Relationship between Propositional Logic and FOPL</strong>
        <br>
        <br>
        <table style="width: 90%;">
        	<tr>
        		<th>Propositional Logic</th>
        		<th>First Order Predicate Logic (FOPL)</th>
        	</tr>
        	<tr>
        		<td>Propositional Logic assumes that there are facts that either hold (TRUE) or do not hold (FALSE).</td>
        		<td>FOPL assumes that there are objects which share real-world relationships that do or do not hold.</td>
        	</tr>
        </table>
        <br>
        <strong>Characteristics of FOPL</strong>
        <ol>
        	<li>It has a sound theoretical foundation</li>
        	<li>Using FOPL, inferencing can be applied upon Predicate Logic</li>
        	<li>It allows for accurate representation of real world facts (Propositions)</li>
        	<li>It is commonly used for program design</li>
        </ol>
        <br>
        <strong>Components of FOPL</strong>
        <ol>
        	<li>
        		<span class="underline">Symbols</span>
        		<ol>
        			<li>
        				<em>Constants</em>: Any fixed value. Must begin with lower case letters. Eg. 6, interest.
        			</li>
        			<li>
        				<em>Variables</em>: can assume different values and are used to represent real world objects.
        			</li>
        			<li>
        				<em>Functions</em>: take one or more arguments and return a value.
        				<br>
        				For eg. x&rarr;x<sup>2</sup>
         			</li>
         			<li>
         				<em>Predicates</em>: take in variables and return a boolean value.
         				<br>
         				For eg.x&rarr;x is even. 
         			</li>
         			<li>
         				<em>Connectives</em>: Just like propositional calculus, FOPL also uses the following 5 connectives:
         				<ol>
         					<li>Conjunction OR AND OR &and;</li>
         					<li>Disjunction OR OR OR &or;</li>
         					<li>Negation OR NOT OR &sim;</li>
         					<li>Implication OR IMPLIES OR &rarr;</li>
         					<li>Equivalence OR &equiv;</li>
         				</ol>
         			</li>
         			<li>
         				<em>Quantifiers</em>: Two types of quantifiers are used:
         				<ol>
         					<li>
         						Universal Quantifier: &forall;
         						<br>
         						&forall;x means "for all x" 
         					</li>
         					<li>
         						Existential Quantifier: &exist;
         						<br>
         						&exist;x means "there exists an (for some) x"
         					</li>
         				</ol>
         			</li>
        		</ol>
        	</li>
        	<li>
        		<span class="underline">Sentences</span>: are of two types:
        		<ol>
        			<li>
        				<em>Atomic Sentences</em>: An atomic sentence is a type of declarative sentence which is either true or false (may also be referred to as a proposition) and which cannot be broken down into other simpler sentences.
        				<br>
        				For eg.
        				<blockquote>
        					brother(Richard, John)
        				</blockquote>
        				which is interpreted as "Richard is a brother of John" if the statement is TRUE.
        			</li>
        			<li>
        				<em>Complex Sentences</em>: Any sentence made up of separate individual atomic sentences, combined using logical connectives.
        			</li>
        		</ol>
        	</li>
        	<li>
        		<span class="underline">Semantics</span>: define the rules for deriving the value of a sentence (TRUE or FALSE).
        	</li>
        </ol>
        <br>
        <strong>Quantifiers</strong>
        <br>
        Quantifiers are used to express properties of entire collections of objects. There are two types of quantifiers:
        <ol>
        	<li>
        		<span class="underline">Universal Quantifier</span>: represented as &forall;, it is used to represent truth values "for all" of the variables.
        		<br>
        		For eg.
        		<blockquote>
        			"All kings are persons." can be represented as "&forall;king(x) &rarr; person(x)"
        		</blockquote>
        	</li>
        	<li>
        		<span class="underline">Existential Quantifier</span>: represented as &exist;, it is used to represent truth values which are true for atleast one interpretation. In other words, &exist; states describes that for a particular interpretation, "there exists" a variable which is TRUE.
        		<br>
        		For eg.
        		<blockquote>
        			"Some people are sick today" can be represented by "&exist;x(people(x) &rarr; sick(x))", which means that there is atleast one person who is sick today.
        		</blockquote>
        	</li>
        </ol>
        <strong>Representing facts using FOPL</strong>
        <span style="color: red;">DO IT YOURSELF, pages 142, 143, 144</span>
        <br>
        <strong>Inferencing in FOPL</strong>
        <span style="color: red;">DO IT YOURSELF, page 145</span>
        <br>
        <strong>Relationship Representation in FOPL</strong>
        <span style="color: red;">DO IT YOURSELF, page 146</span>
        <br>
        <br>
        <strong>Resolution in Predicate Logic (Algorithm)</strong>
        <ol>
        	<li>
        		<span class="underline">Convert all statements to clausal form</span>:
        		<ol>
        			<li>
        				Eliminate implications and double-implications using the following rules:
        				<blockquote>
        					<strong>P&rarr;Q</strong> can be simplified as <strong>&sim;P&or;Q</strong>
        					<br>
        					<strong>P&harr;Q</strong> can be simplified as <strong>(&sim;P&or;Q)&and;(&sim;Q&or;P)</strong>
        				</blockquote>
        			</li>
        			<li>
        				Reduce the number of &sim; using the following:
        				<blockquote>	
    						Either by cancelling &sim;s against each other, for eg. 
    						<br>
    						&sim;(&sim;P) = P
    						<br>
    						Or by using de Morgan's laws, for eg.
    						<br>
    						&sim;(A&and;B) &equiv; &sim;A &or; &sim;B <strong>or</strong> &sim;(&exist;x : P(x)) &equiv; &forall;x &sim;P(x)
    						<br>
    						OR
    						<br>
    						&sim;(A&or;B) &equiv; &sim;A &and; &sim;B <strong>or</strong> &sim;(&forall;x : P(x)) &equiv; &exist;x &sim;P(x)
    					</blockquote>
    					<hr>
    					<blockquote>
    						Technically the only thing you'll ever require to do will be, in case of predicates like
    						<br>
    						<strong>&sim;&exist;x smiling(x)</strong>
    						<br>
    						In cases like these, you'll operate &sim; against the entire expression, which is composed of two parts:
    						<ol>
    							<li>&exist; which describes the "there exists" or "atleast one" part</li>
    							<li>smiling(x) which shows the function and the variable to which the existential quantifier applies</li>
    						</ol>
    						So &sim; will apply to both the parts, individually:
    						<ol>
    							<li>When &sim; interacts with &exist;, it changes into &forall;</li>
    							<li>The &sim; that interacts with the function, remains as it is</li>
    						</ol>
    						<br>
    						So apart from the other two things given above (the de Morgan's laws), do remember this also.
    					</blockquote>
        			</li>
        			<li>
        				Introduce unique variables for all the objects/ entities involved.
        				<br>
        				<blockquote>
        					<strong>&forall;x : (P(x) &rarr; &exist;x(P(x)))</strong> is okay.
        					<br>
        					<strong>&forall;x : (P(x) &rarr; &exist;x(Q(x)))</strong> is NOT okay. Q must be associated with a distinct variable than the one P is associated with. Hence
        					<br>
        					<strong>&forall;x : (P(x) &rarr; &exist;y(Q(y)))</strong> is okay.
        				</blockquote>
        				<hr>
        				<blockquote>
        					Again, the only meaningful thing that you'll ever be required to do, is to associate <strong>every predicate</strong> with a <strong>unique variable</strong>. It doesn't matter what the predicate is, only that every predicate by now should be completely represented by one variable and that variable must be distinct from all other variables being used in all other predicates.
        				</blockquote>
        			</li>
        			<li>
        				<span class="underline">Eliminate Existential Quantifiers</span>: Suppose we get a predicate, 
        				<blockquote>
        					&exist;x graduating(x)
        				</blockquote>
        				We need to <strong>eliminate</strong> the existential quantifier and replace this predicate with the following:
        				<blockquote>
        					graduating(shyam)
        				</blockquote>
        				This newly introduced predicate is called the <strong>Skolem Function</strong> and this process is known as <strong>Skolemiation</strong>. Using this process, if the existential quantifier appears at any place, we need to replace all occurances of the variable it quantifies with an arbitrary constant not appearing anywhere else in the expression and delete the quantifier.
        				<br>
        				For eg. <strong>&exist;x: president(x)</strong> is skolemized as <strong>president(name)</strong>
        				<br>
        				OR
        				<br>
        				<strong>&forall;x : &exist;y : student(y, x)</strong> is skolemized as <strong>&forall;x: student(teacher(x),x)</strong>
        			</li>
        			<li>
        				<span class="underline">Eliminate Universal Quantifiers and bring the expression into the CNF form</span>: Just drop the &forall; quantifiers from the expression and if required, bring the expression into a CNF form (independent terms in the expression must be joined by &and;s).
        			</li>
        		</ol>
        	</li>
        	<li>
        		Now suppose we had to prove <strong>P</strong> as TRUE. So we assume &sim;P is TRUE and add it to the other clauses.
        	</li>
        	<li>
        		Repeat the following until the result is obtained or no further progress can be made (NULL is obtained):
        		<ol>
        			<li>Select two clauses called the "parent" clauses.</li>
        			<li>Resolve them together.</li>
        			<li>If the resolvent is an empty clause, then a contradiction is found. Else if it's not, then add it to the set of clauses available for further resolution.</li>
        		</ol>
        	</li>
        </ol>
        <br>
        <hr>
        <h2 class="part_not_understood">PLEASE SOLVE THE NUMERICALS YOURSELF</h2>
        <h4 class="part_not_understood">Numericals at Pages 153-156, 159, 161-162, 165-190</h4>
        <hr>
        <br>
        <h3>Skolemization?</h3>
        Skolemization is the process of managing quantifiers, summarized as below:
        <ol>
        	<li>Determine which variables are existential and which are universal. We do this while forming the predicates.</li>
        	<li>Eliminate all the existential quantifiers.</li>
        	<li>Rename variables with same names.</li>
        </ol>
        <h3>Unification?</h3>
        It might often happen that we have two or more than two copies of the same predicate where they accept arguments that are fundamentally different (with distinct names) in every case. These predicates cannot be resolved.
        <br>
        <blockquote>
        	For eg. <strong>bigcity(x)</strong> and <strong>bigcity(gurugram)</strong> cannot be resolved.
        </blockquote>
        Hence <strong>Unification</strong> is a technique where similar predicates having different arguments are made <em>identical</em> by using substitutions for those variable argumnets.
       	<br>
       	These substitutions can be made in 3 ways:
       	<ol>
       		<li>Substituion of a variable by a <span class="underline">constant</span></li>
       		<li>Substitution of a variable by <span class="underline">another variable</span></li>
       		<li>Substitution of a variable by a <span class="underline">function</span></li>
       	</ol>
       	Any substitution that makes two or more expressions equal is called a <strong>Unifier</strong> for that expression.
    <h3>Conversion into Horn's Clauses?</h3>
    The process is just the same as that of conversion into normal clauses, as we have studied earlier.
    <ol>
    	<li>Eliminate &harr; and &rarr;</li>
    	<li>Reduce &sim;</li>
    	<li>Standardize variables (each clause should contain it's own unique set of variables)</li>
    	<li>Eliminate Existential Quantifiers</li>
    	<li>Remove Universal Quantifiers</li>
    	<li>Convert into CNF</li>
    </ol>
    <h3>Forward Reasoning & Backward Reasoning?</h3>
    In AI, solution search in the problem's search space can be performed in two possible ways:
    <ol>
    	<li>
    		<span class="underline" id="ForwardChaining">Forward Reasoning (also called as Forward Chaining)</span>: In Forward Chaining, the ES is given the data and it chains forward to reach a conclusion. When the antecedent conditions are met, the rules invoked (IF clauses) are replaced by the RHS (THEN clauses) of the rule. It is also called as data driven search.
    		<ol>
    			<li>The search starts from the start node at the root (data) of the tree representing the solution space.</li>
    			<li>The search proceeds with the expansion of nodes to the left of the root node that match the rules applicable to the root node (towards the solution).</li>
    			<li>Continue until a node matching the goal state is found.</li>
    		</ol>
    		For eg. suppose you get an assignment to prepare a report from a given set of books urgently. Now you don't know what exactly this entire set of data contains, just that you have to create a report during the given time (goal state). So you read them, analyse them (<strong>start from the data</strong>) and create your report (<strong>solution</strong>).
    	</li>
    	<li>
    		<span class="underline" id="BackwardChaining">Backward Chaining (also called as Backward Chaining)</span>: It is the reverse process of forward chaining. In this ES is given a hypothesis and it backtracks to check if it is valid or not. It is a "goal-oriented" or "goal-driven" technique as it tries to prove a goal by confirming the truth of all of its premises. Here the interpreter starts with matching the THEN clauses and if a match occurs, it is replaced by the IF clause.
    		<ol>
    			<li>The search starts from the goal node (solution) of the root of the tree representing the solution space.</li>
    			<li>The search proceeds with the expansion of nodes to the right of the root node that match the rules applicable to the root node (towards the data).</li>
    			<li>Continue until a node matching the start state is found.</li>
    		</ol>
    		For eg. suppose you wake up one morning with the question in your mind "Whether I should wear my sweater today or not?". You already have the goal state in your mind, which tells us that either we will or won't wear a sweater today. So we decide to go from the <strong>solution -> data</strong>. We start accumulating data that if it's cold today by either checking our phone or seeing out from the window.
    	</li>
    </ol>
    In PROLOG, backward chaining applies because it starts searching from the goal state.
    <br>
    The following factors determine the direction of the reasoning process:
    <ol>
    	<li>
    		<span class="underline">No. of start and goal states</span>: Reasoning is always performed from the smaller set of states to the larger set of states. 
    	</li>
    	<li>
    		<span class="underline">Direction of Branching Factor</span>: Reasoning is always performed in the direction of the lower <em>branching factor</em>. <strong>Branching Factor</strong> refers to the average number of nodes that are generated from a single node. The assumtion is that the problem should always <em>converge</em> towards the solution. Hence direction is assumed by reviewing the branching factor of the surrounding nodes.
    	</li>
    	<li>
    		<span class="underline">Requirements of the problem</span>: Some problems require the justification of the reasoning process. So reasoning is chosen in the direction that relates to the way that the user might think.
    	</li>
    </ol>
    <br>
    Refer to the video below for more explanation:
    <br>
    <br>
    <div class="text_center">
    	<strong>Forward and Backward Chaining</strong>
    	<br>
    	<br>
    	<iframe width="100%" height="56.5%" src="https://www.youtube.com/embed/ZhTt-GG7PiQ" frameborder="0" allowfullscreen></iframe>
    	<br>
    </div>
    <h3>Advanced Knowledge Representation?</h3>
    Knowledge representation using proposition and predicate logic is a basic technique. Every knowledge representation technique should have the following:
    <ol>
    	<li>Sufficient expressive power for encoding the knowledge at hand</li>
    	<li>Possess a sematic basis for the user to take out the meaning of the knowledge in the knowledge base.</li>
    	<li>It must allow an efficient algorithmic interpretation</li>
    	<li>Allows for the user to make sense of the solution in terms of the explanation and the justification</li>
    </ol>
    So the Advanced Knowledge representation techniques are:
    <ol>
    	<li>
    		<span class="underline">Semantic Network</span>: is a graphical knowledge representational technique. Semantic Networks are developed to model human memory in the form of graphs, with
    		<blockquote>
    			<strong>Nodes</strong> representing <strong>Objects</strong>
    			<br>
    			&
    			<strong>Arcs</strong> representing <strong>relationships</strong> between those objects
    		</blockquote>
    		Nodes can also, further be of different types:
    		<ol>
    			<li>
    				<span class="underline">Generic Node</span>: represents a general class of nodes. For eg. <em>Aircrafts</em>.
    			</li>
    			<li>
    				<span class="underline">Individual or Instance Node</span>: represents a specific instance (of a class node). For eg. <em>Bf 109</em>
    			</li>
    		</ol>
    		Similarly, arcs are also of two types:
    		<ol>
    			<li>is-a</li>
    			<li>has-part</li>
    		</ol>
    		<br>
    		<strong>Features of Semantic Networks</strong>
    		<hr>
	        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
	        <p style="display: block; margin: 0 auto; text-align: center; color: orange;">It is advised to study this part with the notes at hand for the several accompanying diagrams and examples.</p>
	        <hr>
	        <br>
	        <ol>
	        	<li>
	        		<span class="underline">Semantic Networks</span>: can easily represent inheritable knowledge so efficiently that the meaning of a concept can be derived from the ways it is displayed to be connected to the other concepts.
	        	</li>
	        	<li>
	        		<span class="underline">Intersection Search</span>: Relationships can be derived between objects not related directly using intersection search
	        	</li>
	        </ol>
	        <br>
	        <hr>
	        <h2 class="part_not_understood">PLEASE SOLVE THE NUMERICALS YOURSELF</h2>
	        <h4 class="part_not_understood">Numericals at Pages 194, 195, 196</h4>
	        <hr>
	        <br>
	        <strong>Advantages of Semantic Networks</strong>
	        <ol>
	        	<li>Graphical Representation, hence easy to visualise.</li>
	        	<li>Inheritance Relationships ("is a" links) are easy to represent.</li>
	        	<li>Related knowledge can be easily clustered.</li>
	        	<li>
	        		Minimal space requirements as:
	        		<ol>
	        			<li>Objects are represented only once</li>
	        			<li>Relationships are handled as pointers</li>
	        		</ol>
	        	</li>
	        </ol>
	        <strong>Disadvantages of Semantic Networks</strong>
	        <ol>
	        	<li>Inheritance from multiple sources can cause problems in representation.</li>
	        	<li>Inappropriately placed facts can cause problems.</li>
	        	<li>Not well suited for representing negations, disjunctions, conditionals, etc.</li>
	        </ol>
    	</li>
    	<br>
        <hr>
        <h2 class="part_not_understood">PLEASE SOLVE THE NUMERICALS YOURSELF</h2>
        <h4 class="part_not_understood">Numericals at Pages 201, 202, 203</h4>
        <hr>
        <br>
    	<li>
    		<span class="underline">Frames</span>: are a record like structure which consist of a collection of attributes and their corresponding values. They help in organizing knowledge related to conceptual events in the form of small packets, called frames.
    		<br>
    		<div style="color: red; margin: 0 auto;">See the accompanying example</div>
    		<br><br>
    		A general frame structure is as follows:
    		<br>
    		<br>
    		<strong>Frame Name -> Slot Numbers -> Facet Numbers -> Corresponding Values</strong>
    		<div style="color: red; margin: 0 auto;">See the associated representation in the notes</div>
    		<br><br>
    		A frame may have any number of slots, slots may have any number of facets.
    		<br>
    		Slots contain general information like:
    		<ol>
    			<li>Attribute Value Pairs</li>
    			<li>Default Values</li>
    			<li>Pointers to other related frames</li>
    			<li>Procedures required</li>
    		</ol>
    		<br>
    		Based on the information that they contain, frames can be of two types:
    		<ol>
    			<li>
    				<span class="underline">Declarative Frames</span>: contain only descriptive knowledge
    			</li>
    			<li>
    				<span class="underline">Procedural Frames</span>: contain knowledge about the actions or procedures.
    			</li>
    		</ol>
    		<br>
			A normal frame  typically consists slots for:
			<ol>
				<li>
					<span class="underline">Actor</span>: contains information about <strong>WHO</strong> is performing the activity
				</li>
				<li>
					<span class="underline">Object</span>: contains information about <strong>WHAT</strong> is being operated upon
				</li>
				<li>
					<span class="underline">Source</span>: contains information about the <strong>BEGINNING</strong> of the action
				</li>
				<li>
					<span class="underline">Destination</span>: contains information about the <strong>END</strong> of the action
				</li>
			</ol>
			<blockquote>
				Frames are usually linked together in a network through the use of special pointers called <strong>AKO</strong> or <strong>A Kind Of</strong> pointers
			</blockquote>
			<h3>Advantages and Disadvantages of Frame Representation</h3>
			<table>
				<tr>
					<th>Advantages</th>
					<th>Disadvantages</th>
				</tr>
				<tr>
					<td>Frames collect information about an object in a single place in an organized fashion, thus associating knowledge with their objects</td>
					<td>Inheritance can cause trouble</td>
				</tr>
				<tr>
					<td>Allows data that is required to be stored and referred to in a uniform manner</td>
					<td>There can be more than one way to breakdown the world into taxonomies</td>
				</tr>
			</table>
			<br>
    	</li>
    	<li>
    		<span class="underline">Conceptual Dependency</span>: Any sentence has syntactic, semantic and conceptual level. At the conceptual level the complete concept of the sentence is understood.
    		<br>
    		<br>
    		Conceptual Representation is required to represent the meaning of natural languages, like English, in an unambiguous way. It is beneficial because:
    		<ol>
    			<li>Drawing inferences</li>
    			<li>Natural Language Representation</li>
    		</ol>
    		<br>
    		In CD, agents and objects interact with each other and these collectively are called as concepts. These concepts are of three types:
    		<ol>
    			<li>
    				<span class="underline">Nominal (represented as <strong>PP</strong>)</span>: These are the participating objects. These can be of two types:
    				<ol>
    					<li>
    						<span class="underline">Concrete Objects</span>: like "Car".
    					</li>
    					<li>
    						<span class="underline">Abstract Objects</span>: like "Gravity".
    					</li>
    				</ol>
    			</li>
    			<li>
    				<span class="underline">Action (represented as <strong>ACT</strong>)</span>: is what a <em>nominal</em> does.
    			</li>
    			<li>
    				<span class="underline">Modifier</span>: modify <em>nominals</em> or <em>actions</em>. These are further of two types:
    				<ol>
    					<li>
    						<span class="underline">Picture Aider (represented as <strong>PA</strong>)</span>: describes the picture (object).
    					</li>
    					<li>
    						<span class="underline">Action Aider (represented as <strong>AA</strong>)</span>: describes the action (the the object is doing).
    					</li>
    				</ol>
    				<br>
    				Some primitive actions are:
    				<br><br>
    				<table>
    					<tr>
    						<th style="padding: 1em;">ACTIONS</th>
    						<th>DESCRIPTIONS</th>
    					</tr>
    					<tr>
    						<th>ATRANS</th>
    						<td>transfer of abstract objects. Eg. <em>give</em>, <em>take</em>, <em>accept</em>, etc.</td>
    					</tr>
    					<tr>
    						<th>MTRANS</th>
    						<td>transfer of mental information. Eg. <em>tell</em>.</td>
    					</tr>
    					<tr>
    						<th>PTRANS</th>
    						<td>transfer of physical location of an object. Eg. <em>go</em>, <em>come</em>, <em>run</em>,, <em>walk</em>, etc.</td>
    					</tr>
    					<tr>
    						<th>PROPEL</th>
    						<td>applying physical force to an object causing it's location/ position to change. Eg. <em>push</em>, <em>pull</em>, <em>throw</em>, etc.</td>
    					</tr>
    					<tr>
    						<th>MOVE</th>
    						<td>movement of a body part. Eg. <em>punch</em>, <em>kick</em>, etc.</td>
    					</tr>
    					<tr>
    						<th>GRASP</th>
    						<td>actor grasping onto an object. Eg. <em>hold</em>, <em>clutch</em>, etc.</td>
    					</tr>
    					<tr>
    						<th>INGEST</th>
    						<td>actor ingesting an object. Eg. <em>eat</em>, <em>drink</em>, etc.</td>
    					</tr>
    					<tr>
    						<th>EXPEL</th>
    						<td>expulsion of an object from the body of an actor. Eg. <em>cry</em>, etc.</td>
    					</tr>
    					<tr>
    						<th>MBUILD</th>
    						<td>using old facts/ knowledge to derive new information. Eg. <em>decide</em>, etc.</td>
    					</tr>
    					<tr>
    						<th>SPEAK</th>
    						<td>speaking, in general. Eg. <em>say</em>, etc.</td>
    					</tr>
    					<tr>
    						<th>ATTEND</th>
    						<td>focusing a sense organ towards a stimulus. Eg. <em>listen</em>, etc.</td>
    					</tr>
    				</table>
    			</li>
    		</ol>
    		<br>
    		<strong>Tenses</strong>
    		<br>
    		Tenses/ Moods are used for describing events. These are as below:
    		<br>
    		<br>
    		<table>
    			<tr>
    				<th>TENSE SYMBOL</th>
    				<th>TENSE MEANING</th>
    			</tr>
    			<tr>
    				<th>p</th>
    				<td>past tense</td>
    			</tr>
    			<tr>
    				<th>k</th>
    				<td>continuing action</td>
    			</tr>
    			<tr>
    				<th>f</th>
    				<td>future tense</td>
    			</tr>
    			<tr>
    				<th>t</th>
    				<td>transition</td>
    			</tr>
    			<tr>
    				<th>ts</th>
    				<td>transition start</td>
    			</tr>
    			<tr>
    				<th>tf</th>
    				<td>transition finish</td>
    			</tr>
    			<tr>
    				<th>?</th>
    				<td>interrogation</td>
    			</tr>
    			<tr>
    				<th>/</th>
    				<td>negation</td>
    			</tr>
    			<tr>
    				<th>c</th>
    				<td>conditional</td>
    			</tr>
    			<tr>
    				<th>o</th>
    				<td>object-case relationship</td>
    			</tr>
    			<tr>
    				<th>&Delta;</th>
    				<td>timeless</td>
    			</tr>
    		</table>
    		<br>
    		<hr>
	        <h2 class="part_not_understood">PLEASE SOLVE THE NUMERICALS YOURSELF</h2>
	        <h4 class="part_not_understood">Numericals at Pages 214-219</h4>
	        <hr>
    		<br>
    		<h3>Advantages and Disadvantages of Conceptual Dependency (CD)</h3>
			<table>
				<tr>
					<th>Advantages</th>
					<th>Disadvantages</th>
				</tr>
				<tr>
					<td>Inferential knowledge is easily and efficiently represented in CD structures.</td>
					<td>Representation can be complex even for fairly simple actions.</td>
				</tr>
				<tr>
					<td>The holes in the intial structure help bring focus onto the areas that still need understanding.</td>
					<td>Knowledge must be decomposed into fairly low level primitives, and even then it can be impossible to find out a correct set of primitives.</td>
				</tr>
			</table>
			<br>
    	</li>
    	<li>
    		<span class="underline">Scripts</span>: are structures that describe an event as a collection of circumstances that can be anticipated to follow/ occur one after the other. They are beneficial because:
    		<ol>
    			<li>Events normally occur in known patterns.</li>
    			<li>An informed relation (order) exists between the events.</li>
    			<li>The entry condition for an event exists.</li>
    		</ol>
    		<br>
    		There are certain key components of any script. These are:
    		<ol>
    			<li>
    				<span class="underline">Entry Condition</span>: must be satisfied before the events in the script can occur.
    			</li>
    			<li>
    				<span class="underline">Result</span>: are the conditions that will be true after the events in the script have occured.
    			</li>
    			<li>
    				<span class="underline">Props</span>: are the objects involved in the occurance of the entire event. 
    			</li>
    			<li>
    				<span class="underline">Roles</span>: are the persons (characters) involved in the event.
    			</li>
    			<li>
    				<span class="underline">Track</span>: marks the variation in scripts.
    			</li>
    			<li>
    				<span class="underline">Scene</span>: Lists the sequence of events that occur at a particular location or circumstance.
    			</li>
    		</ol>
    		<h3>Advantages and Disadvantages of Scripts</h3>
			<table>
				<tr>
					<th>Advantages</th>
					<th>Disadvantages</th>
				</tr>
				<tr>
					<td>Provide an abillity to list and predict/ anticipate events that are about to unfold.</td>
					<td>May not be suitable to represent all kinds of knowledge.</td>
				</tr>
				<tr>
					<td>An entire interpretation of the event may be built up from observations.</td>
					<td>Less general than frames</td>
				</tr>
			</table>
			<br>
			<hr>
	        <h2 class="part_not_understood">PLEASE SOLVE THE NUMERICALS YOURSELF</h2>
	        <h4 class="part_not_understood">Numericals at Pages 222-229</h4>
	        <hr>
    		<br>
    	</li>
    </ol>
    <h2 id="Module3">Module 3: Natural Language Processing</h2>
    <br>
    <h3>Natural Language Processing?</h3>
    Natural Language Processing or NLP is a branch of Artificial Intelligence that deals with analyzing, understanding and generating the languages that humans use to interact with each other so that computers can perform various value added tasks. It has benefits like:
    <ol>
    	<li>Easier representation of new and complex concepts</li>
    	<li>Development of User Friendly AI became possible</li>
    </ol> 
    <h3>Natural Language?</h3>
    It refers to the language spoken by humans, eg. English opposite to artificial and computer-understandable languages like C++. While artificial languages are rigid, natural languages are flexible.
    <h3>Goal of NLP?</h3>
    To write a program that can understand and produce natural language.
    <h3>Applications of NLP?</h3>
    <ol>
    	<li>To index and search large texts.</li>
    	<li>Speech Recognition</li>
    	<li>Information Extraction</li>
    	<li>Knowledge acquisition</li>
    	<li>Language Translation</li>
    </ol>
    <hr>
    <h2 class="additional_reference">STUDY OF THIS TOPIC REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
    <div style="display: block; margin: 0 auto; text-align: center; color: orange;">Please refer to the <strong>NLP Block Diagram</strong> mentioned in the notes for this topic</div>
    <hr>
    <h3>Machine Translation?</h3>
    It refers to an area of NLP that deals with translation of text from one human (natural) language to another with the aim of high speed conversion & accuracy.
    <h3>Some early NLP Systems?</h3>
    <ol>
    	<li>
    		<span class="underline">ELIZA</span>
    		<ol>
    			<li>Developed at MIT</li>
    			<li>Mimics a psychotherapist</li>
    			<li>Keyword-based analysis approach, has no further understanding of the conversation</li>
    		</ol>
    	</li>
    	<li>
    		<span class="underline">LUNAR System</span>
    		<ol>
    			<li>Is a question-answering system</li>
    			<li>Had a separate syntax and symantic analyzer, used ATN.</li>
    		</ol>
    	</li>
    	<li>
    		<span class="underline">SHRDLU System</span>
    		<ol>
    			<li>Used a dialogue system to converse with a human user</li>
    			<li>Used hand-eye simulations to better convey the idea/ message</li>
    		</ol>
    	</li>
    </ol>
    <h3>A general NLP System?</h3>
    <ol>
    	<li><strong>Input</strong> is provided in the natural language</li>
    	<li>The input is then parsed by the <strong>parser</strong> and a parse tree is generated</li>
    	<li>The <strong>semantic interpreter</strong> captures the meaning</li>
    	<li>The <strong>conversation rules</strong> then use the above for <strong>database storage</strong> point of view</li>
    </ol>
    <hr>
    <h2 class="additional_reference">STUDY OF THIS TOPIC REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
    <div style="display: block; margin: 0 auto; text-align: center; color: orange;">Please refer to the diagram for <strong>General NLP System</strong> mentioned in the notes for this topic</div>
    <hr>
    <h3>Types of Ambiguities in Natural Languages?</h3>
    <ol>
    	<li>
    		<span class="underline">Lexical Ambiguity</span>: occurs when similar words used have different meanings.
    		<br>
    		For eg. "bank" which means a place to deposit your money safely AND a river bank.
    	</li>
    	<li>
    		<span class="underline">Syntactic Ambiguity</span>: occurs when a sentence can be parsed in more than one way giving rise to two (or more) meanings. It can be resolved using common sense knowledge.
    		<br>
    		For eg. the sentence "I saw the boy with telescope." has two meanings:
    		<ol>
    			<li>Seeing a person with the help of a telescope</li>
    			<li>Seeing a person in posession of a telescope</li>
    		</ol>
    		After reading the above mentioned meanings, we can easily decide upon the correct meaning using common sense.
    	</li>
    	<li>
    		<span class="underline">Referential Ambiguity</span>: occurs when the usage of pronouns can introduce ambiguity as to what do they refer to. This type of ambiguity can be resolved using contextual knwoledge.
    		<br>
    		For eg. <strong>"John saw a neautiful car at the showroom. He showed it to Bob. He bought it."</strong>
    		Here "he" can refer to John or Bob and also "it" can refer to either the car or the showroom.
    	</li>
    	<li>
    		<span class="underline">Pragmatic Ambiguity</span>: occurs because of a different underlying intentional meaning of a sentence than the one it appears to have. To resolve this kind of ambiguity, common sense knowledge and contectual knowledge is required.
    		<br>
    		For eg. seeing an employee coming late to office, the boss might say "What's the time?". This sentence, although looks like a simple one, rather carries the intention of making the defaulter realise his mistake.
    	</li>
    </ol>
    <h3>Phases of Natural Language Processing?</h3>
    Natural Language Processing is divided into two parts:
    <ol>
    	<li>
    		<span class="underline">Natural Language Understanding</span>: It is a process on its own and can be broken down into the following steps:
    		<ol>
    			<li>
    				<strong>Morphological Analysis</strong>: means <em>studying the word structure</em>. In this phase individual words are analyzed into their components called "morphemes". Non-word tokens, like punctuation symbols, etc. are separated from the words.
    				<blockquote style="text-align: center;">
    					A <strong>morpheme</strong> is the basic grammatical building block that consists of individual words. It is the minimal meaningful unit of a langauge that cannot be broken down further.
    				</blockquote>
    				For eg. lets consider the sentence <em>"I want to print Bill's .init file"</em> and see how Morphological Analysis works upon it:
    				<ol>
    					<li>Pull apart the proper noun <em>Bill</em> and the suffix <em>s</em>.</li>
    					<li>Recognize <em>.init</em> as an adjective.</li>
    					<li>Assign similar categories to rest all the words in the sentence.</li>
    				</ol>
    			</li>
    			<li>
    				<strong>Syntactic Analysis</strong>: checks the valididty of a sentence according to the grammatical rules. The goal of this phase, called <em>parsing</em>, means that a flat sentence has to be converted into a hierarchical structure that has been designed to correspond to the different sentence units (such as <em>noun phrases</em>).
    				<br>
    				<strong>Basics of Syntactic Analysis</strong>
    				<ol>
    					<li>
    						<em>Syntax</em>: provides rules to put together words to form components of a sentence, and then to put together those components to form sentences.
    						<br>
    						Knowledge of syntax helps in:
    						<ol>
    							<li>Parsing</li>
    							<li>Generation</li>
    							<li>Translation, etc.</li>
    						</ol>
    					</li>
    					<li>
    						<em>Grammar</em>: is the formal specification of the rules of a language.
    					</li>
    					<li>
    						<em>Parsing</em>: is a method to perform syntactic analysis of a sentence.
    						<hr>
						    <h2 class="additional_reference">STUDY OF THIS TOPIC REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
						    <div style="display: block; margin: 0 auto; text-align: center; color: orange;">Please refer to the block diagram for <strong>Parsing</strong> mentioned in the notes for this topic</div>
						    <hr>
    					</li>
    					<li>
    						<em>Lexicon</em>: is a dictionary of words, where each word contains some syntactic, semantic and pragmatic information.
    					</li>
    				</ol>
    				<strong>Information Conveyed by a Parse Tree</strong>
    				<ol>
    					<li>
    						Which <em>"Part of Speech"</em> every word in a sentence belongs to, that is <em>Noun (N), Verb (V) or Determiner (D)</em>
    					</li>
    					<li>
    						The <em>phrases</em> a sentence is composed of. For eg. in the sentence <em>"The burglar robbed the apartment"</em>, there are 3 phrases that can be formed:
    						<ol>
    							<li>
    								<em>Noun Phrase (NP)</em>: The burglar
    							</li>
    							<li>
    								<em>Verb Phrase (VP)</em>: robbed the apartment
    							</li>
    							<li>
    								<em>Sentence (S)</em>: The burglar robbed the apartment
    							</li>
    						</ol>
    					</li>
    				</ol>
    				<strong>Context Free Grammar (CFG)</strong>
    				CFG is represented as <em>G = (N, T, P, S)</em> where
    				<ol>
    					<li>
    						<em>N</em> stands for the set of non-terminals
    					</li>
    					<li>
    						<em>T</em> stands for the set of terminals
    					</li>
    					<li>
    						<em>P</em> stands for the set of production rules
    					</li>
    					<li>
    						<em>S</em> stands for the Start Symbol
    					</li>
    				</ol>
    				<strong>A CFG for English</strong>
    				<br>
    				<em>N</em> = {N, NP, VP, PP, DT, Vi, Vt, NN}
    				<br>
    				<em>T</em> = {sleeps, man, saw, etc.}
    				<br>
    				<em>P</em> = 
    				<br>
    				&nbsp;&nbsp;&nbsp;S -> NP VP
    				<br>
    				&nbsp;&nbsp;&nbsp;VP -> Vi
    				<br>
    				&nbsp;&nbsp;&nbsp;VP -> Vt NP
    				<br>
    				&nbsp;&nbsp;&nbsp;NP -> DT NN
    				<br>
    				&nbsp;&nbsp;&nbsp;NP -> NP PP
    				<br>
    				&nbsp;&nbsp;&nbsp;PP -> IN NP
    				<br>
    				&nbsp;&nbsp;&nbsp;Vi -> sleeps, etc.
    				<br>
    				&nbsp;&nbsp;&nbsp;Vt -> saw, etc.
    				<br>
    				&nbsp;&nbsp;&nbsp;NN -> man | woman | ...
    				<br>
    				&nbsp;&nbsp;&nbsp;DT -> the
    				<br>
    				&nbsp;&nbsp;&nbsp;IN -> with, in
    				<br>
    				<em>S</em> = S
    				<hr>
    				<blockquote>
    					Reference to the different symbols used above (on the RHS, for the LHS symbols see the topic on CFG above):
    					<ol>
    						<li>
    							<em>N</em>: Total Set, would be present in every CFG's set of N (Non- Terminals)
    						</li>
    						<li>
    							<em>S</em>: Sentence
    						</li>
    						<li>
    							<em>VP</em>: Verb Phrase
    						</li>
    						<li>
    							<em>NP</em>: Noun Phrase
    						</li>
    						<li>
    							<em>PP</em>: Prepositional Phrase
    						</li>
    						<li>
    							<em>DT</em>: Determiner
    						</li>
    						<li>
    							<em>Vi</em>: Intransitive Verb
    						</li>
    						<li>
    							<em>Vt</em>: Transitive Verb
    						</li>
    						<li>
    							<em>NN</em>: Noun
    						</li>
    						<li>
    							<em>IN</em>: Preposition
    						</li>
    					</ol>
    				</blockquote>    				
    				<hr>
    				<strong>Parsing Techniques</strong>
    				<br>
    				Parsing Techniques are of two types:
    				<ol>
    					<li>
    						<em>Top Down Parsing</em>: Begin at the start symbol and apply the given rules forward until the terminals, which are the words of the sentence have been produced.
    					</li>
    					<li>
    						<em>Bottom Up Parsing</em>: Begin with the sentence to be parsed and apply the grammar rules backward until the start symbol has been produced.
    					</li>
    				</ol>
    				<div class="text_center">
			        	<img src="images/04cparsing_Page_1.jpg" alt="Top Down & Bottom Up Parsing" style="width: 90%; height: 120%; border: 5px solid black;">
			        </div>
    				<hr>
			        <h2 class="part_not_understood">PRACTISE THE ADDITIONAL NUMERICALS/ PROBLEMS</h2>
			        <h4 class="part_not_understood">Problems given on Page No. 243 - 247</h4>
			        <hr>
			        <strong>Transition Network</strong>
			        <br>
			        A transition network is a graphical representation that represents the syntactic structure of a sentence. It consists of nodes and labled arcs in which nodes represent the various states and arcs represent the transitions between those states. A sentence is accepted by the transition network if there is a path from the start node to the finish node.
			        <hr>
			        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
			        <div style="display: block; margin: 0 auto; text-align: center; color: orange;">See the accompanying examples.</div>
			        <hr>
			        If a sentence doesn't satisfy the structure, the parsing fails.
			        <br>
			        <br>
			        <em>Advantages and Disadvantages of Transition Networks</em>
			        <br>
			        <br>
			        <table>
			        	<tr>
			        		<th>Advantages</th>
			        		<th>Disadvantages</th>
			        	</tr>
			        	<tr>
			        		<td>A good method to represent grammers and do parsing</td>
			        		<td>Can only accept simple sentences</td>
			        	</tr>
			        	<tr>
			        		<td>Easy to implement</td>
			        		<td>Fail to recognize all of the languages generated by CFG</td>
			        	</tr>
			    	</table>
			    	<br>
			    	<strong>Recursive Transition Network</strong>
			    	<br>
			    	It is a modified version of the above-mentioned transition network. It counters the disadvantages offered by the Transition Network (abillity to accept only simple sentences and failure to accept all languages generated by CFG). To do this, it permits arcs to refer to other networks, in the following way:
			    	<ol>
			    		<li>It labels some arcs as a separate network state (such as NP for "Noun Phrase")</li>
			    		<li>It then constructs the different subnetworks mentioned</li>
			    		<li>Hence a single subnetwork (for eg. the one for NP) can then be called from several places</li>
			    		<li>Similarly arcs can be labelled for other sentence constituents like VP (Verb Phrase), PP (Prepositional Phrase) and others.</li>
			    	</ol>
			    	<hr>
			        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
			        <div style="display: block; margin: 0 auto; text-align: center; color: orange;">See the accompanying examples.</div>
			        <hr>
			        A parse can hence fail if either of the following two conditions are obtained:
			        <ol>
			        	<li>If the end of the I/P sentence has been reached</li>
			        	<li>If a word in the I/P sentence fails to satisfy any of the available arcs</li>
			        </ol>
			        <br>
			        <em>Disadvantages of Recursive Transition Network</em>
			        <br>
			        The one disadvantage of this approach is that parts of a sentence may be parsed more than once resulting in excessive computation.
			        <br>
			        <br>
			        <strong>Augmented Transition Network (ATN)</strong>
			        <br>
			        The networks considered so far are not very useful for language understanding. They are very capable at accepting or rejecting a sentence based on whether it satisfies the grammar or not but don't don't capture the real meaning of the sentence. In order to do that, additional features for capturing semantic information must be included, like mood, tense and so on. Without these additional tests, meaningless sentences may be accepted.
			        <br>
			        When a RTN is given these additional features, it is called an Augmented Transition Network (ATN). It uses the same notational and processing conventions as the RTN, but each arc can have a further arbitrary test/ action which store additional semantic knowledge about the sentence.
			        <hr>
			        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
			        <div style="display: block; margin: 0 auto; text-align: center; color: orange;">See the accompanying examples.</div>
			        <hr>
    			</li>
    			<li>
    				<strong>Semantic Analysis</strong>: deals with the meaning of the natural language sentences. It performs two things:
    				<ol>
    					<li>It must be able to map the individual words approximately to the existing objects in the knowledge base.</li>
    					<li>It must create correct structures that corresponds to the way the individual words combine together to give a meaning to the sentence.</li>
    				</ol>
    				Hence structures for which no mapping could be done are rejected.
    				There are several phases in Semantic Analysis. These are:
					<ol>
						<li>
					    	<em>Lexical Processing</em>: The first step that any semantic processing system does is look up the individual words (lexicons) for their meanings. However many words have multiple meanings and it might not be possible to choose the correct meaning in the first go.
					    	<br>
					    	For eg. "bark" means two things
					    	<ol>
					      		<li>The outer covering of a tree</li>
					      		<li>The sound a dog makes</li>
					    	</ol>
					    	To separate the different meanings a word might have and to choose the correct one out of them is called "Word Sense Disambiguation" or "Lexical Disambiguation".
					  	</li>
					  	<li>
					    	<em>Sentence Level Processing</em>: includes
					    	<ol>
					      		<li>
					        		<em>Semantic Grammars</em>: encode semantic information into a syntactic grammar. Further the choice of Non Terminals and Production Rules is governed by semantic as well as syntactic functions.
					      		</li>
					      		<li>
					        		<em>Case Grammars</em>: In Case Grammars, grammar rules are written for syntactic purposes and corresponding structures are then produced that map to symantic knowledge.
					      		</li>
					      		<li>
					        		<em>Conceptual Parsing</em>: is driven by a dictionary that describes the meanings of words as conceptual dependency structures.
					      		</li>
					    	</ol>
					  	</li>
					</ol>
    			</li>
    			<li>
    				<strong>Pragmatic & Discourse Analysis</strong>: To understand the meaning of a single sentence, it is necessary to consider the context in which the sentence was uttered. There are a number of ways relationships between parts of a sentence and it's context can exist. These are:
    				<ol>
    					<li>
    						<em>Identical Entities</em>: For eg. "Bill has a balloon. John wants it too."
    						<br>
    						Here "it" should be identified as referring to the "red balloon".
    					</li>
    					<li>
    						<em>Part of Entities</em>: For eg. "She opened the book she had just bought. The title page was torn."
    						<br>
    						The phrase "The title page" should be recognized as a part of the "book" that was just bought.
    					</li>
    					<li>
    						<em>Parts of actions</em>: For eg. "John went on a business trip to New York. He left on an early morning flight."
    						<br>
    						Taking an "early morning flight" in the second sentence should be considered a pert of the "business trip to New York" action in the first sentence.
    					</li>
    				</ol>
    			</li>
    		</ol>
    	</li>
    	<li>
    		<span class="underline">Natural Language Generation</span>: It is the process of generating Natural Language output from non-linguistic input.
    		<hr>
	        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
	        <div style="display: block; margin: 0 auto; text-align: center; color: orange;">See the NLG Block Diagram from the notes.</div>
	        <hr>
	        Every NLG operation can be decomposed into the following tasks:
			<ol>
				<li>
			    	<em>Lexical Detection</em>: approximately selecting the correct word from the lexicon.
			  	</li>
			  	<li>
			  		<em>Content Selection</em>: approximately selecting the correct content to express input. 
			  	</li>
			  	<li>
			    	<em>Sentence Selection</em>: appropriately selecting the correct phrases to frame a sentence
			  	</li>
			  	<li>
			  		<em>Referring Expressions</em>: approximately selecting how to refer to the objects being discussed
			  	</li>
			  	<li>
			    	<em>Discourse Structure</em>: Now that we have our sentences, generate a suitable structure among the multiple sentences
			  	</li>
			  	<li>
			    	<em>Conceptualization</em>: This is a general framework corresponding to the application is decided. Words are chosen from lexicons according to the concepts. They are then converted to sentences and at last surface ralization converts these to a Natural Language output. 
			  	</li>
				<hr>
		        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
		        <div style="display: block; margin: 0 auto; text-align: center; color: orange;">See the NLG Generation Block Diagram from the notes.</div>
		        <hr>
			</ol>
			<strong>Components of NLG</strong>
			<ol>
				<li>
					<em>Discourse Planner</em>: performs the following functions:
					<ol>
						<li>accepts inputs and decides the goals</li>
						<li>takes decisions about content selections</li>
						<li>plans the discourse</li>
					</ol>
				</li>
				<li>
					<em>Surface Realizer</em>: receives the discourse plans and generates individual sentences. It handles decisions like lexical selection, content selection, etc.
				</li>
				<li>
					<em>Computational Grammar</em>: Grammar is a declarative description of a language. It can be of the following types:
					<ol>
						<li>
							<em>Context Free Grammar</em>: used for context free languages
						</li>
						<li>
							<em>Transformational Grammar</em>: Transformational Grammars are used for languages in which the meaning of the sentence depends upon the context. They use CFG rules to represent the meaning of a sentence. To start with, we have a <em>deep structure</em>, which is a basic sentence built by CFG. It is represented as a parse tree that consists of terminals, non-terminals and other semantic information like tenses, etc. When transformational rules are applied on a deep structure, the structure generated is called a <em>surface structure</em>. There are a variety of transformation rules that can be applied, as below:
							<ol>
								<li>
									<em>Aux Inversion</em>: This rule converts an imperative sentence into an interrogative sentence.
								</li>
								<li>
									<em>Reflexivization</em>: This rule adds a subscript <em>i</em> with noun phrase which indicates that two noun phrases refer to same individual.
								</li>
								<li>
									<em>Imperatives</em>: This rule helps in assumption of "you" in the sentence and leads to "you deletion" from the sentence's parse tree.
								</li>
								<li>
									<em>Passive</em>: This rule helps capture the relation between active and passive sentences.
								</li>
								<li>
									<em>Dative Movement</em>: is designed for sentences with a direct and indirect object. 
								</li>
							</ol>
							<hr>
					        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
					        <div style="display: block; margin: 0 auto; text-align: center; color: orange;">See the accompanying examples.</div>
					        <hr>
						</li>
					</ol>
				</li>
			</ol>
    	</li>
    </ol>
    <h3>Speech Recognition</h3>
    Speech Recognition is the task of identifying a sequence of words uttered by a speaker. It can be a difficult process because words can have varying pronunciations and further words with different meanings may have the same pronunciations. Moreover the presence of noise may change or distort the acoustic signal uttered by the speaker.
    <br>
    Some basic terminology of Speech Recognition is as below:
    <ol>
    	<li>
    		<span class="underline">Phoneme</span>: The smallest unit of sound in a language.
    	</li>
    	<li>
    		<span class="underline">Word</span>: A single distinct meaningful element of speech or writing, used with others to form a sentence.
    	</li>
    	<li>
    		<span class="underline">Sentence</span>: A meaningful collection of words.
    	</li>
    	<li>
    		<span class="underline">Speech Recognition</span>: It is a system that has separate modules for pronunciation models, language processing algorithms, etc.
    	</li>
    </ol>
    <h3>Machine Learning</h3>
    Machines cannot be called intelligent until they are able to learn how to do new things or adapt to new situations as against simply doing things that they are told to be done. Machine Learning is the field of study that gives computers the abillity to learn and do new things or old things in a better manner without being explicitely programmed to do so.
    <br>
    In other words, a computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performace on T as measured by P, improves with experience E. For eg. an email spam filter which learns from experience as you mark mails "spam" so as to auto-categorize those or similar mails in future as spam, by itself.
    <hr>
    <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
    <div style="display: block; margin: 0 auto; text-align: center; color: orange;">See the accompanying Block Diagram of a General Learning System.</div>
    <hr>
    Two features that every machine learning system has, are as below:
    <ol>
    	<li>
    		<span class="underline">Skill Refinement</span>: refers to improving the skill of the learning system by performing the same task again and again.
    	</li>
    	<li>
    		<span class="underline">Knowledge Acquisition</span>: refers to the process of executing tasks as they come and then remembering the process for future use, in case a similar task comes again. It is done in two steps:
    		<ol>
    			<li>Initial knowledge base construction is done by feeding the initial facts about the task</li>
    			<li>Further refinement, if any, is done later by feeding additional knowledge</li>
    		</ol>
    	</li>
    </ol>
    Different types of learning menthods used are as below:
    <ol>
    	<li>
    		<span class="underline">Rote Learning</span>: refers to learning through memorization. It is an elementary form of learning where data of a particular task is simply stored. For eg. if a game is played, the system will remember the winning sequence of moves and apply them whenever it plays that game again, until a better sequence of moves comes by. This process is called caching. It is the process of storing computed values or large amounts of data in a way that it can be recalled again as and when required by the computation.
    		<br>
    		<br>
    		<table>
    			<tr>
    				<th>Advantages</th>
    				<th>Disadvantages</th>
    			</tr>
    			<tr>
    				<td>
    					<em>Organized Storage of Information</em>: which helps in reuse of this stored information as and when repetition of a previous task is performed.
    				</td>
    				<td>
    					<em>Stability of Environment</em>: If the problem domain is an environment where problems rapidly come and go (become redundant quickly) then rote learning is not efficient.
    				</td>
    			</tr>
    			<tr>
    				<td>
    					<em>Generalised Information</em>: When you're keeping information stored about each and every task your system perfoms, you're bound to sometime discover some of that information relevant to a similar task that you are asked to perform and hence all that abundance of stored information becomes generalised in a matter of time and can even be applied to a large number of similar tasks that may come efficiently.
    				</td>
    				<td></td>
    			</tr>
    		</table>
    	</li>
    	<li>
    		<span class="underline">Learning by taking advice</span>: happens when the system run the program along the advice of the programmer. Common approaches of advice taking are:
    		<ol>
    			<li>
    				<strong>Rules</strong>: help in advice automation such as:
    				<ol>
    					<li>
    						<em>Advice Requests</em>: asking about general advice
    					</li>
    					<li>
    						<em>Advice Interpretations</em>: translating received advice into internal representation
    					</li>
    					<li>
    						<em>Advice Operationalizations</em>: provide a representation of the advice
    					</li>
    					<li>
    						<em>Advice Integration</em>/: removing redundancies and contradictions from Knowledge Base
    					</li>
    					<li>
    						<em>Advice Evaluation</em>: by the system for errors, contradictions, etc.
    					</li>
    				</ol>
    			</li>
    			<li>
    				<strong>Tools</strong>: like debuggers.
    			</li>
    		</ol>
    	</li>
    	<li>
    		<span class="underline">Learning by Problem Solving</span>: A problem can be solved faster by experience and hence efficiency of solving a similar problem increases by experience.  
    	</li>
    	<li>
    		<span class="underline">Inductive Learning</span>: refers to learning from examples.Inductive learning means generalization of knowledge gathered from real world examples and then using that knowledge for solving other similar problems. 
    	</li>
    	<li>
    		<span class="underline">Explanation Based Learning</span>: Learning approaches can be of two types: 
    		<ol>
    			<li>
    				<strong>Knowledge Intensive Approach</strong>: like Explanation Based Learning.
    			</li>
    			<li>
    				<strong>Data Intensive Approach</strong>: like Rote Learning.
    			</li>
    		</ol>
    		In this method one example in form of a past experience is sufficient for learning a new solution. One positive training example is sufficient to perform the learning. Important features of EBL are:
    		<ol>
    			<li>Formal statement about the goal</li>
    			<li>Domain theory that relates to the concept and training example</li>
    			<li>Minimum one training example</li>
    			<li>Criteria for applying an operator</li>
    		</ol>
    	</li>
    </ol>
    <h3>Reasoning with Uncertainity</h3>
    The real world is full of situations where the data and information is uncertain to begin with. Possible sources of uncertainities are:
    <ol>
    	<li>Most of the acquired knowledge is through belief and hypothesis</li>
    	<li>Natural language has a certain vagueness associated</li>
    	<li>Experimental errors are sources of uncertainity</li>
    	<li>Randomeness of events also causes uncertainity</li>
    </ol>
    Hence representation of uncertain knowledge requires an additional factor tekn into account indicating the correctness of knowledge called "degree of belief". It is associated with each stated fact and it's value ranges between 0 & 1.
    <br>
    Three basic types of reasoning methods exist where problems don't have uncertainities associated:
    <ol>
    	<li>
    		<strong>Inductive Reasoning</strong>: This reasoning is based on the generalization of the previous experiences about the problem and then using that experience to establish facts that have not been explicitely stated.
    		<br>
    		For eg. knowing the name of the school a student studies in, we can infer many things like the quality of education he is getting, the general school environment he is exposed to, etc.
    	</li>
    	<li>
    		<strong>Abductive Reasoning</strong>: This reasoning looks back through the chain of events to perform reasoning. It is not always very reliable because it might not always capture all of the background details.
    		<br>
    		For eg. a teacher getting angry at a student as he's entering the class. Why? Because he's late. But then it also could be that the student hasn't done his homework. So it's not very reliable.
    	</li>
    	<li>
    		<strong>Deductive Reasoning</strong>: In case of deductive reasoning, the conclusion is deducted from the premise. However the reverse cannot be always true.
    		<br>
    		For eg. the premise given is that "the switch is off" and the corresponding conclusion that may be derived is "the bulb is not producing light". However as we see, there can be many reasons a bulb may not produce light and hence the reverse is not always true.
    	</li>
    </ol>
    In certain situations, the knowledge base only stores consistent information where every conclusion that may be drawn from the existing knowledge shall be true under all circumstances. This is called <em>Monotonic Reasoning</em>. For eg. Predicate and propositional logic.
    <br>
    However to deal with uncertain knowledge, conclusions are drawn on the basis of what is most likely to be true. The following two approaches are used for reasoning with uncertain situations:
    <ol>
    	<li>
    		<strong>Non-Monotonic Reasoning</strong>: All knowledge stored in the knowledge base is done in accordance with the belief associated with them. There is uncertainity associated with them and if any new knowledge comes that contradicts the existing knowledge, the old knowledge facts need to be modified. Hence knowledge grows in a non-monotonic manner and is hence called non-monotonic reasoning.
    		<br>
    		There are two approaches for non-monotonic reasoning:
    		<ol>
    			<li>
    				<em>Abduction</em>: infers the situation based on the facts currently available and also the past events. When any new contradictory event or fact is encountered, the previous knowledge is removed and the new knowledge is stored. This type of reasoning is useful when there is some measure of certainity attached with the incoming knowledge for them to be considered above the existing contradictory knowledge.
    			</li>
    			<li>
    				<em>Property Inheritance</em>: works on the principle that all sub-classes of a parent class derive all the properties of the parent class, unless specifically stated otherwise.
    			</li>
    		</ol>
    		<br>
    		<strong>Truth Maintenance System</strong>
    		<br>
    		<br>
    		At the time of the initial designing of any system, the available knowledge is very less, inconsistent and full of redundancies. TMS are the support system that maintain the consistency of the knowledge base. When new knowledge  is found to be inconsistent with the earlier knowledge, TMS corrects and updates the knowledge base with the true knowledge.
    		<br>
    		Some TMS types are:
    		<ol>
    			<li>
    				<em>Justification Based TMS (JTMS)</em>: In JTMS, each sentence in the Knowledge Base is annotated with a justification consisting of a set of sentences from which it was inferred.
    			</li>
    			<li>
    				<em>Assumption Based TMS (ATMS)</em>: In ATMS, each sentence in the Knowledge Base is annotated with a justification, assuming that they will be required at a later point of time.
    			</li>
    			<li>
    				<em>Logic Based TMS (LTMS)</em>: In LTMS, each sentence in the Knowledge Base is annotated with the corresponding logic that lead to it's inclusion into the Knowledge Base.
    			</li>
    			<hr>
			    <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
			    <div style="display: block; margin: 0 auto; text-align: center; color: orange;">See the accompanying Block Diagram of a Truth Maintenance System.</div>
			    <hr>
			    <br>
    		</ol>
    	</li>
    	<li>
    		<strong>Probabalistic Reasoning</strong>: is a method that can be used to strengthen the knowledge representation techniques with statistical measures that describe levels of evidence and belief. Some basic axioms of probability theory are:
    		<ol>
    			<li>The probability of occurance of any event lies between 0 and 1, that is 0 <em>&le; P(A) &le; 1</em></li>
    			<li>An event having probability 1 means that it is certain to happen, that is P(A) = 1</li>
    			<li>An event with probability 0 means that it will never happen, that is P(A) = 0</li>
    			<li>P(E<sub>1</sub> &cup; E<sub>2</sub> &cup; ... E<sub>n</sub>) = P(E<sub>1</sub>) + P(E<sub>2</sub>) + ... + P(E<sub>n</sub>)</li>
    		</ol>
    		<br>
    		There are two types of Probabilities:
    		<ol>
    			<li>
    				<em>Unconditional Probability</em>: finding the probability of an event prior to occurance of any event supporting the event's occurance or absence. Denoted as P(Event).
    			</li>
    			<li>
    				<em>Conditional Probability</em>: finding the probability of an event after the occurance of an event supporting the event's occurance or absence. Denoted as P(Event | evidence). For eg. Bayesian Reasoning (Bayes Theorem).
    			</li>
    		</ol>
    		<br>
	        <hr>
	        <h2 class="part_not_understood">PLEASE SOLVE THE NUMERICALS for BAYES THEOREM YOURSELF</h2>
	        <h4 class="part_not_understood">Numericals at Pages 281 - 284</h4>
	        <hr>
	        <br>
			<em>Limitations of Bayes Theorem</em>
			<ol>
				<li>The space required to store all these probabilities would be too large</li>
				<li>The time required to compute all these probabilities would be too large</li>
			</ol>
			<br>
			<em>Bayesian Networks</em>: is graphical model for the probabilistic relationship among a set of variables.
			<br>
	        <hr>
	        <h2 class="part_not_understood">SEE THE ASSOCIATED EXAMPLE ON BAYESIAN NETWORKS</h2>
	        <h4 class="part_not_understood">At Page No. 285-286</h4>
	        <hr>
	        <br>
	        <em>Reasoning with Fuzzy Sets</em>: Formal Logic fails when dealing with real life situations because of the vagueness involved. Hence Fuzzy Set theory was introduced to deal with real life vague situations.
	        <br>
	        In classical set theory, the characteristic function (membership function) has a value equal to 1 if the element belongs to the crisp set or 0 if it does not belong to the crisp set. These are the only two possible values that can exist because in classical set theory, either a person belongs to the set or it doesn't belong to the set.
	        <br>
	        Since we take care of vagueness in fuzzy set theory, the memebership function for the elements in a fuzzy set can have a variety of values. An element can have its membership function's value equal to 1 if the element completely belongs to the fuzzy set, 0 if the element completely does not belong to the fuzzy set and between 0 and 1 if the element partially belongs to the fuzzy set.
	        <br>
	        <hr>
	        <h2 class="part_not_understood">SEE THE ASSOCIATED GRAPHS AND THE EXAMPLES ON FUZZY SET THEORY</h2>
	        <h4 class="part_not_understood">At Page No. 287-289</h4>
	        <hr>
	        <br>
	        <em>Reasoning with Certainity Factors</em>
	        <br><br>
	        In theory we can describe probabilities for events with utmost precision. For example if asked whether it'd rain today, you caould say that there are 80% chances of raining today but the fact is that in most real life situations, we can never absolutely state how certainly an event is bound to happen or how uncertain is the occurance of another event. The most that we have is a belief or confidnce in the occurance or non-occurance of an event. Hence for real-life events, we use the following two confidence measures:
	        <ol>
	        	<li>
	        		<em>MB(H|E)</em>: Measure of belief or confidence for the hypothesis H in the presence of evidence E
	        	</li>
	        	<li>
	        		<em>MD(H|E)</em>: Measure of disbelief or confidence against the hypothesis H in the presence of evidence E
	        	</li>
	        </ol>
	        Finally, the difference between these two measures of belief is defined as the <em>certainity factor (CF)</em>, as below:
	        <blockquote style="text-align: center;">
	        	CF(H|E) = MB(H|E) - MD (H|E)
	        </blockquote>
	        The value of CF may vary between +1 and -1, as the value approaches to +1 the evidence is stronger for a hypothesis & as the CF approaches -1 the confidence against the hypothesis gets stronger. CF = 0 indicates that little evidence exists for or against the hypothesis.
    	</li>
    </ol>
    <br>
    <h2 id="Module4">Module 4: Expert Systems</h2>
    <br>
    <ul>
    	<li>An Expert System is an intelligent computer program that uses knowledge and inference procedures to solve problems that are difficult enough to require significant human expertise for their solutions.</li>
    	<li>An expert, is a person who has specialization and expertise in a particular field and has knowledge and skills which most other people do not have.</li>
    	<li>An expert system, hence, is an intelligent computer program which acts intelligently and solves the problem in the same manner in which a human expert will do. Hence an ES can be said to be a computer program that emulates decision making abillity and problem solving capability of a human expert.</li>
    	<li>They provide solutions by applying inference methods to a specific body of knowledge called domain knowledge, limited to a particular domain. Hence Expert Systems can only work in limited domains that require human expertise like medical diagnosis, data interpretation, credit checking, etc.</li>
    	<li>
    		<strong>Expert System = Inference Engine + Knowledge</strong>, where <strong>Expert Knowledge</strong> is a combination of <em>Theoretical Understanding</em> of a problem and a collection of <em>heuristic problem solving techniques</em>.</em>
    	</li>
    </ul>
    <h3>Process of Acquiring Knowledge</h3>
    <ol>
    	<li>Giving the ES a problem to solve</li>
    	<li>Getting comments from Human Experts about the results</li>
    	<li>Modifications are done to the ES, as suggested by the Human Experts after consideration of the above received solution, if required</li>
    	<li>The process is repeated until the ES exhibits the desired level of performance</li>
    </ol>
    <h3>Expert Systems VS Human Experts</h3>
    <table>
    	<tr>
    		<th>Advantages of Expert Systems/ Disadvantages of Human Experts</th>
    		<th>Advantages of Human Experts/ Disadvantages of Expert Systems</th>
    	</tr>
    	<tr>
    		<td>
    			<span class="underline">Easy Availability</span>: An expert system can be mass produced and can work 24x7, no matter what the place of requirement. Human Experts are not easily available and have limited working hours.
    		</td>
    		<td>
    			<span class="underline">Presence of Common Sense</span>: In addition to deep knowledge of the problem domain, human experts are also able to apply heuristic knowledge and common sense, something ES do not possess.
    		</td>
    	<tr>
    		<td>
    			<span class="underline">Economy</span>: Although ES are really expensive to build and maintain, they are inexpensive to operate and hence are much more economical than human experts.
    		</td>
    		<td>
    			<span class="underline">Learning from Experience</span>: Human Experts automatically and continually learn and adapt according to the changing environment while ES needs to be explicitely programmed and updated.
    		</td>
    	</tr>
    	<tr>
    		<td>
    			<span class="underline">Permanence</span>: Human Experts may die, but the expertise of ES is forever.
    		</td>
    		<td>
    			<span class="underline">Creativity</span>: Human Experts can respond creatively to unusual problems, the ES can not.
    		</td>
    	</tr>
    	<tr>
    		<td>
    			<span class="underline">Multiple Expertise</span>: Multiple ES can work on a single problem at a time while it's difficult to make multiple humans work on a single problem at once.
    		</td>
    		<td>
    			<span class="underline">Flexibility and Robustness</span>: When encountered with a problem, the human experst can keep trying repeatedly until they find a solution. However the ES just follows its inbuilt logic and will always produce the same result unless updated or modified.
    		</td>
    	</tr>
    	<tr>
    		<td>
    			<span class="underline">Fast Response</span>: ES, since they are computers, are much faster than humans.
    		</td>
    		<td>
    			<span class="underline"></span>
    		</td>
    	</tr>
    	<tr>
    		<td>
    			<span class="underline">Steady and Unemotional</span>: ES are machines and hence emotions or circumstances don't affect their results.
    		</td>
    		<td>
    			<span class="underline"></span>
    		</td>
    	</tr>
    </table>
    <h3>Characteristics of AI</h3>
    <ol>
    	<li>
    		<span class="underline">Performance</span>: The performance of an ES must at least match that of human experts
    	</li>
    	<li>
    		<span class="underline">Response Time</span>: The response time of the ES must be comparatively low
    	</li>
    	<li>
    		<span class="underline">Quality of Solution</span>: The solution provided by the ES must be of a high quality, along with their explanation and justification
    	</li>
    	<li>
    		<span class="underline">Use of Heuristic Knowledge</span>: System must use more and more heuristic knowledge to solve the problem
    	</li>
    	<li>
    		<span class="underline">Reliability</span>: ES must be reliable in their functioning and solutions.
    	</li>
    	<li>
    		<span class="underline">Flexible</span>: The ES must be flexible enough to accomodate changes in Knowledge Base
    	</li>
    </ol>
    <h3>Architecture of Expert System (ES)</h3>
    <hr>
    <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
    <div style="display: block; margin: 0 auto; text-align: center; color: orange;">See the accompanying Block Diagram of the <strong>Architecture of an Expert System</strong></div>
    <hr>
    Core components of an ES are:
    <ol>
    	<li>
    		<span class="underline">User Interface</span>: accepts queries from the user in human-understandable language and transforms it into a language understood by ES.
    	</li>
    	<li>
    		<span class="underline">Explanation Module</span>: allows the program to explain its reasoning to the user. The explanation of the ES is necessary because:
    		<ol>
    			<li>The user of the program needs to be satisfed that the program solution is correct</li>
    			<li>Explanations provide feedback to the knowledge engineers, so that they can check if the knowledge is applied correctly or not</li>
    			<li>To trace the way knowledge is applied</li>
    		</ol>
    	</li>
    	<li>
    		<span class="underline">Knowledge Base</span>: is the core module of any ES. It can be acquired from various sources by applying knowledge acquisition techniques.
    	</li>
    	<li>
    		<span class="underline">Knowledge Acquisition</span>: is the process of gathering knowledge. Some knowledge acquisition methods are given as below:
    		<ol>
    			<li>
    				<strong>Interview Method</strong>: Knowledge can be acquired by interacting and interviewing the human experts.  This job is done by the <em>Knowledge Engineer</em>.
    				<hr>
				    <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
				    <div style="display: block; margin: 0 auto; text-align: center; color: orange;">See the accompanying Block Diagram of <strong>Knowledge Acquisition in ES</strong></div>
				    <hr>
				    Some problems in Knowledge Acquisition are as below:
				    <ol>
				    	<li>Sometimes its difficult for human experts to communicate their knowledge verbally</li>
				    	<li>Sometimes the conceptual aspects of facts cannot be precisely mathematically characterized</li>
				    </ol>
				    The Knowledge Acquisition Cycle for this method is descibed as below:
				    <ol>
				    	<li>Knowledge acquired from expert</li>
				    	<li>Acquired knowledge documented</li>
				    	<li>
				    		Test this new knowledge as below:
				    		<ol>
				    			<li>Employ Experts to analyze this new set of data</li>
				    			<li>Analyze the same set of knowledge in terms of docuemnted knowledge</li>
				    			<li>Compare the result of expert opinion taken above</li>
				    			<li>If results differ, find the rules that generated discrepancy and start from the top again to acquire knowledge</li>
				    		</ol>
				    	</li>
				    </ol>
				    <hr>
				    <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
				    <div style="display: block; margin: 0 auto; text-align: center; color: orange;">See the accompanying Block Diagram of <strong>Knowledge Acquisition Cycle in ES for Interview Method</strong></div>
				    <hr>
    			</li>
    			<li>
    				<strong>Knowledge Base Knowledge Acquisition</strong>: In this method of acquisition, the working of expert system has given feedback regarding the lapses in knowledge acquisition. Hence such feedback is taken into consideration by the experts who then look into the process of domain knowledge acquisition and inference more closely.
    			</li>
    		</ol>
    	</li>
    	<li>
    		<span class="underline">Knowledge Representation</span>: is the proces of describing and mapping expert knowledge using a set of symbols and attaching meaning to the syntax.
    		<br>
    		Knowledge Representation has the following characteristics:
    		<ol>
    			<li>
				<span style="text-decoration: underline;">Logical Completeness</span>: The knowledge representation technique chosen should be capable of describing the concepts completely.
				</li>
				<li>
					<span style="text-decoration: underline;">Heuristic Power</span>: The knowledge must be represented in a way to allow for easy and straight-forward solution of the problems.
				</li>
				<li>
					<span style="text-decoration: underline;">Notational Convenience</span>: The notations chosen for representation must be easy to convert into code.
				</li>
    		</ol>
    		The following techniques are used for knowledge representation:
			<ol>
				<li>Semantic Networks</li>
				<li>Rules</li>
				<li>Frames</li>
				<li>AND/ OR Diagrams</li>
			</ol>
			The most commonly used KR Structure is the IF-THEN-ELSE structure.
			<br>
			For eg. <strong>IF</strong> marks secured by student is &lt;50 <strong>THEN</strong> declare him as failed.
		</li>
		<li>
			<span class="underline">Inference Engine</span>: The real strength of ES lies in their capacity to make inferences (drawing conclusions) from given premises. To do this, an ES uses and <strong>Inference Engine</strong>. An Inference Engine does so using the following steps:
			<ol>
				<li>Decides which rules are satisfied by facts</li>
				<li>Decides the priority of the satisfied rules</li>
				<li>Executes the rule with the highest priority</li>
			</ol>
			The inference engine performs the following tasks:
			<ol>
				<li>It matches the IF condition of a rule with the given input condition. If the match occurs then that rule is triggered.</li>
				<li>Add conclusions drawn to the Knowledge Base as inferred facts for future use.</li>
				<li>Trace the rules applied to arrive at a solution in future.</li>
			</ol>
			For eg.
			<br>
			<br>
			<div style="min-width: 33%; display: inline-block;">
				<strong>RULE:</strong> Red Light
				<br>
				IF the light is red
				<br>
				THEN stop
			</div>
			<div style="min-width: 33%; display: inline-block;">
				<strong>RULE:</strong> Yellow Light
				<br>
				IF the light is yellow
				<br>
				THEN look
			</div>
			<div style="min-width: 32%; display: inline-block;">
				<strong>RULE:</strong> Green Light
				<br>
				IF the light is green
				<br>
				THEN go
			</div>
			<br>
			<br>
			Inferencing can be of two types:
			<ol>
				<li>
					<strong>Forward Chaining</strong>: Click <a href="#ForwardChaining">here</a> to study about it
					<br>
					For eg.
					<br>
					<br>
					Given the production rules:
					<br>
					<ol>
						<li>
							IF F<sub>1</sub> and F<sub>2</sub> THEN C<sub>1</sub>
						</li>
						<li>
							IF F<sub>3</sub> and C<sub>1</sub> THEN C<sub>3</sub>
						</li>
						<li>
							IF F<sub>6</sub> THEN C<sub>3</sub>
						</li>
						<li>
							IF F<sub>2</sub> and C<sub>3</sub> THEN C<sub>4</sub>
						</li>
						<li>
							IF C<sub>4</sub> THEN C<sub>5</sub>
						</li>
						<li>
							IF C<sub>2</sub> THEN C<sub>3</sub>
						</li>
						<li>
							IF C<sub>5</sub> THEN C<sub>6</sub>
						</li>
					</ol>
					<br><br>
					Assuming that F<sub>1</sub> and F<sub>2</sub> are true, let's find if C<sub>6</sub> is true or not.
					<br><br>
					<table>
						<tr>
							<th>Rule No.</th>
							<th>Rule Status</th>
							<th>Inferred Fact</th>
						</tr>
						<tr>
							<td>1</td>
							<td>Applied</td>
							<td>C<sub>1</sub></td>
						</tr>
						<tr>
							<td>2</td>
							<td>Applied</td>
							<td>C<sub>3</sub></td>
						</tr>
						<tr>
							<td>3</td>
							<td>Not-Required</td>
							<td></td>
						</tr>
						<tr>
							<td>4</td>
							<td>Applied</td>
							<td>C<sub>4</sub></td>
						</tr>
						<tr>
							<td>5</td>
							<td>Applied</td>
							<td>C<sub>5</sub></td>
						</tr>
						<tr>
							<td>6</td>
							<td>Not-Required</td>
							<td></td>
						</tr>
						<tr>
							<td>7</td>
							<td>Applied</td>
							<td>C<sub>6</sub></td>
						</tr>
					</table>
				</li>
				<br>
				<li>
					<strong>Backward Chaining</strong>: Click <a href="#BackwardChaining">here</a> to study about it
					<br><br>
					For eg. Using the above premises, as given in forward chaining, let's prove that C<sub>6</sub> is true, using backward chaining.
					<br><br>
					<table>
						<tr>
							<th>Rule</th>
							<th>Rule No.</th>
							<th>Condition Matched</th>
							<th>Rule Inferred</th>
						</tr>
						<tr>
							<td>C<sub>6</sub></td>
							<td>7</td>
							<td>IF C<sub>5</sub> and C<sub>6</sub></td>
							<td>C<sub>5</sub></td>
						</tr>
					</table>
					and so on...
				</li>
			</ol>
	    </li>
	    <strong>Design of Expert System</strong>
	    <br>
	    An ES is designed using the following steps:
	    <ol>
	    	<li>
	    		<span class="underline">Analysis</span>: First, the problem is analysed whether its appropriate for an expert system solution or not, in the following ways:
	    		<ol>
	    			<li>The solution of the problem using an ES should justify the costs and efforts involved.</li>
	    			<li>The problem solution should not require the use of common-sense knowledge, something that the ES does not have.</li>
	    			<li>A problem solvable using traditional techniques should be avoided to be solved using ES.</li>
	    			<li>Before starting on finding the problem solution using an ES, the presence of human experts in the problem domain must be guaranteed.</li>
	    		</ol>
	    	</li>
	    	<li>
	    		<span class="underline">Specification</span>: The capabilities expected from the ES are defined in this step, by the developer.
	    	</li>
	    	<li>
	    		<span class="underline">Development</span>: happens in two phases:
	    		<ol>
	    			<li>
	    				<em>Knowledge Acquisition</em>: The developer has the task to gather the following types of knowledge from his discussions with the human experts:
	    				<ol>
	    					<li>
	    						<em>Current</em>: by watching the human experts' current performance
	    					</li>
	    					<li>
	    						<em>Historical</em>: by watching the human experts' perfromances in the past
	    					</li>
	    					<li>
	    						<em>Hypothetical</em>: by having the expert describe how they expect the ES to perform in a hypothetical situation
	    					</li>
	    				</ol>
	    				The developer can hence group the knowledge thus obtained into three categories:
	    				<ol>
	    					<li>
	    						<em>Strategic Knowledge</em>: to determine system flow
	    					</li>
	    					<li>
	    						<em>Judgemental Knowledge</em>: to refine the reasoning process of the ES
	    					</li>
	    					<li>
	    						<em>Factual Knowledge</em>: to describe the various objects used in the ES and their characteristics
	    					</li>
	    				</ol>
	    			</li>
	    			<li>
	    				<em>Prototype System</em>: is a conceptual model of ES which consists of high level descriptions of the tasks and situations. It consists of:
	    				<ol>
	    					<li>Inferences, representations and control structures</li>
	    					<li>Knowledge Base</li>
	    					<li>Verifications and Validations</li>
	    				</ol>
	    			</li>
	    		</ol>
	    	</li>
	    	<li>
	    		<span class="underline">Deployment</span>: The basic development cycle involves rapid prototype development and iterative testing and modification of that prototype with both experts and users. Hence in this phase the developer installs the system for routine use and also continues to fix bugs and update the ES during the product lifecycle.
	    	</li>
	    </ol></ol>
	    Let's now consider an example of an Expert System:
	    <h3>MYCIN - Case Study</h3>
	    MYCIN is a medical ES, developed at Stanford in 1976. It was used for diagnosing bacterial infectious diseases, and in particular for treating blood infections.
	    <hr>
        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
        <p style="display: block; margin: 0 auto; text-align: center; color: orange;">Please refer to the block diagram of <strong>MYCIN</strong></p>
        <hr>
        It consists of the following operational modules:
        <ol>
        	<li>
        		<span class="underline">Static Knowledge Base</span>: contains the features and judgemental knowledge about the domain
        	</li>
        	<li>
        		<span class="underline">Dynamic Patient Database</span>: contains the information regarding the patient
        	</li>
        	<li>
        		<span class="underline">Consultation Program</span>: interacts with the user, asks questions, draws conclusions and gives advice
        	</li>
        	<li>
        		<span class="underline">Explanation Module</span>: justifies the advice given by the ES using the static knowledge, patient data and by tracing program execution
        	</li>
        	<li>
        		<span class="underline">Knowledge Acquisition</span>: adds new rules or changes the existing ones according to program findings
        	</li>
        </ol>
        Hence the general program flow looked like something as below:
        <ol>
        	<li>Deciding how severe is the infection</li>
        	<li>Determining the possible microorganisms involved</li>
        	<li>Selecting the set of probable medications applicable</li>
        	<li>Prescribing the most appropriate drug</li>
        </ol>
        <br>
        <strong>Knowledge Base & Control Structure of MYCIN</strong>
        <br>
        MYCIN's Knowledge Base cnsists of numerous rules, such as the one below:
        <br>
        <br>
        <strong>IF</strong>
        <br>
        the stain of the organism is <em>X</em>
        <br>
        <strong>AND</strong> the morphology of the organism is <em>Y</em>
        <br>
        <strong>AND</strong> the aerobicity of the organism is <em>Z</em>
        <br>
        <strong>THEN</strong>
        <br>
        the evidence strongly suggests that the class of the microorganism is <em>M</em>
        <br>
        <br>
        Hence the control structure of MYCIN follows a similar IF-THEN structure, like one below:
        <br>
        <br>
        <strong>IF</strong>
        <br>
        there is an microorganism which requires therapy
        <br>
        <strong>AND</strong> patient has already been consulted in reference to a different microorganism requiring therapy
        <br>
        <strong>THEN</strong>
        <br>
        compile a list a possible diagnosis and suggest the best one
        <h3>R1 - Case Study</h3>
        The R1 program was a production-rule-based system written by John P. McDermott in 1978 to assist in the ordering of computer systems by automatically selecting the computer system components based on the customer's requirements. The development of XCON followed two previous unsuccessful efforts to write an expert system for this task, in FORTRAN and BASIC.<br>
		In developing the system, McDermott made use of experts from computer systems groups. These experts sometimes even disagreed amongst themselves as to an optimal configuration. The resultant "sorting it out" had an additional benefit in terms of the quality of the systems delivered.<br>
		R1 first went into use in 1980. It eventually had about 2500 rules. By 1986, it had processed 80,000 orders, and achieved 95-98% accuracy. It was estimated to be saving $25M a year by reducing the need to give customers free components when technicians made errors, by speeding the assembly process, and by increasing customer satisfaction.<br>
		Before R1, when ordering a computer, every cable, connection, and bit of software had to be ordered separately. The sales people were not always very technically expert, so customers would find that they had hardware without the correct cables, printers without the correct drivers, a processor without the correct language chip, and so on. This meant delays and caused a lot of customer dissatisfaction and resultant legal action. R1 interacted with the sales person, asking critical questions before printing out a coherent and workable system specification/order slip.<br>
		R1's success led to development of further improved versions having much varied and improved abillities.
        <h3>Neural Networks</h3>
        The neural network is an artificial representation of the human brain that tries to simulate its learning process using a mathematical or computational model. Artificial Neural Net (ANN) or simply Neural Net (NN) learns by examples.
        <br>
        <br>
        <strong>Need of Neural Networks</strong>
        <br>
        Humans are good ub handling fuzzy situations and recognizing images while computers outperform humans in doing calculations and arithmetic operations. Hence using neural networks, we can supplement the enormous processing power of computers with the abillity to make sensible decisions using the learning from past experiences.
        <br>
        <br>
        <strong>Biological Neuron Model</strong>
        All neurons have:
        <ol>
        	<li>
        		<span class="underline">Soma</span>: the cell body that contains the nucleus, etc.
        	</li>
        	<li>
        		<span class="underline">Dendrites</span>: branching fibers that extend from Soma
        	</li>
        	<li>
        		<span class="underline">Axon</span>: singular fibre that carries information away from one neuron to another
        	</li>
        	<li>
        		<span class="underline">Synapse</span>: point of connection between two neurons or a neuron and a muscle cell
        	</li>
        </ol>
        <strong>Information Flow in Neural Cell</strong>
        <ol>
        	<li>The dendrites recieve transmissions from other neurons</li>
        	<li>Soma processes these incoming transmissions and converts them into outgoing transmissions</li>
        	<li>The axon carries the output transmission to other neurons</li>
        	<li>Synapse allows the transmission to cross from one neuron's axon to another's dendrite. This takes place sue to diffusal of chemicals called neurotransmitters.</li>
        </ol>
        <strong>Artificial Neuron Model</strong>
        <br>
        It is a mathematical model conceived as a simple model of a biological neuron. It works in the following manner:
        <ol>
        	<li>A set of input connections bring in activation signals from other neurons. Each incoming input channel has a certain weight associated with it. Hence, each incoming input is multiplied with this characteristic weight of the neural connection. +ve weight excites and -ve weight inhibits.</li>
        	<li>
        		The neuron's processing unit then sums up the inputs and applies an activation function. An activation function can be any function, for eg. the sign function given below:
        		<br>
        		<br>
        		sgn(x) = { 1 if x &ge; 0 <strong>/</strong> 0 if x &lt; 0}
        	</li>
        	<li>Neurons generally do not fire (produce output) unless their total input goes above a certain threshold value. Once a neuron's inputs sums above it's threshold value, it is said to be activated and produces an output transmission.</li>
        </ol>
        <hr>
        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
        <p style="display: block; margin: 0 auto; text-align: center; color: orange;">Please refer to the associated example for the same on Page No. 319</p>
        <hr>
        <h3>Neural Network Architecture</h3>
        An ANN is a data processing system consisting of a large number of simple highly interconnected processing elements (neurons) and can be represented using a directed graph G where vdertices V represent neurons and edges E represent the synaptic links between the neurons. ANNs can have the following possible archiectures:
        <ol>
        	<li>
        		<span class="underline">Single Layer Feed Forward Network</span>: consists of a single layer of weights. The synaptic links carrying weights connects every input to every output.
        	</li>
        	<li>
        		<span class="underline">Multiplayer Feed Forward Network</span>: Besides the input and output layers it has one or more intermediary layers called the hidden layers, composed of neurons called as hidden neurons. The hidden layers are responsible for intermediary computation before directing the input to the output layers.
        	</li>
        	<li>
        		<span class="underline">Feedback ANN</span>: They have atleast one feedback loop where the output of a neuron is feeded back into itself as input. They are also called as recurrent networks.
        	</li>
        	<hr>
	        <h2 class="additional_reference">STUDY OF THIS PROBLEM REQUIRES A REFERENCE TO ADDITIONAL MATERIAL</h2>
	        <p style="display: block; margin: 0 auto; text-align: center; color: orange;">Please refer to the associated diagrams for the same on Page No. 320-321</p>
	        <hr>
        </ol>
        <h3>Learning in Neural Networks</h3>
        Following types of learnings exist in neural networks:
        <ol>
        	<li>
        		<span class="underline">Supervised Learning</span>: The learning pattern is based on comparison between network's corrected output and the generated output, consisting of errors. The errors generated are then analysed to modify the system for improved characteristics. For all these purposes, a supervisor is present.
        	</li>
        	<li>
        		<span class="underline">Unsupervised Learning</span>: The expected or corrected output is not present in this case. The system learns on its own by by discovering and adapting to the inputs presented to it. A supervisor is not present.
        	</li>
        	<li>
        		<span class="underline">Reinforced Learning</span>: The correct or desired output is not present, but only the indication that an output is correct or incorrect is present. A supervisor is present to look over the operations. The system is rewarded for correct answers and penalised for incorrect ones.
        	</li>
        	<li>
        		<span class="underline">Hebbian Learning</span>: The input and output pattern pairs are associated with a respective weight matrix and the final correlation matrix thus found helps analyse the system's performance.
        	</li>
        </ol>
        <h3>Applications of Neural Networks</h3>
        <ol>
        	<li>Pattern Recognition</li>
        	<li>Approximation Systems</li>
        	<li>Prediction Systems</li>
        </ol>
        <h3>Back Propagation</h3>
        It is a common method of training artificial neural networks. It is a supervised learning method and requires a dataset of the desired output among many other things to make up the training set. The algorihm of the same is as below:
        <ol>
        	<li>Select some random initial values for the system parameters</li>
        	<li>Calculate the error associated for these values</li>
        	<li>Change the system parameters for the next run so as to minimise the error obtained</li>
        	<li>Repeat steps 2 & 3 until the error comes to 0</li>
        </ol>
        <br>
	    <h2 id="Module5">Module 5: Robotics</h2>
	    <br>
	    <h3>Introduction</h3>
	    It is a combination of microprocessor and conventional automation systems which provides for a very powerful system. It has a high level machinery capabilities combined with fault recognition and correction abilities provided by highly evolved computer systems. This means it can carry out work traditionally carried out by humans.<br>
	    Human beings are the highest level of autonomous systems because they think and they can change plan at any moment due to their high intelligence.<br>
		Robots cannot reach the same high level as humans because they are programmed to do certain tasks according to certain factors which are completely programmed by human beings, but they have no possibilities to change plan like humans or plan new things unless the programmer programs them to change the plan.
		<h3>Applications</h3>
		<ol>
			<li>
				<span class="underline">Welding</span>: Robots are greatly helpful in industrial applications like welding because of the hazardous nature of work. Welding releases noxious fumes, highly dangerous for humans. Moreover its a strenous job and hence it's difficult for humans to perform it as efficiently as robots can. 
			</li>
			<li>
				<span class="underline">Painting</span>: Painting, as its done in the industry is called spray painting. This is a highly hazardous environment to be working in and hence robots are used to do it efficiently.
			</li>
			<li>
				<span class="underline">Assembly Operations</span>: Electronics are now-a-days very high-tech and complex and are made of several important and small components that make up a modern industrial circuit. Humans cant handle this level of complexity or detail and hence robots are used to assemble these systems.
			</li>
		</ol>
		<h3>Advatanges of using Robots</h3>
		<ol>
			<li>
				<span class="underline">Consistent Quality</span>: at high standards can be achieved by a robot. A robot can easily be re- programmed many times to reach the highest possible quality which a human cannot often achieve. 
			</li>
			<li>
				<span class="underline">Safety</span>: is especially important when a robot handles chemicals, bio chemicals, toxic and nuclear products. They can be handled very safely and smoothly, saving humans from carrying out high risk, stress inducing work.
			</li>
			<li>
				<span class="underline">Robots can carefully handle fragile and tiny parts</span>: such as glass, small chips and wires. 
			</li>
			<li>
				<span class="underline">Inspection and maintenance tasks in dangerous areas</span>: for example handling explosives, exploring the deep sea, space and other planets. One example is the shipwrecked Titanic. A robot was used to discover the ships content as it lay so deep under the ocean it was beyond human reach. 
			</li>
			<li>
				<span class="underline">Space missions</span>: to gather samples from other planets and to analyze them from remote distances. 
			</li>
		</ol>
		<h3>Types of Robots</h3>
		<ol>
			<li>
				<span class="underline">Industrial (painting and welding) robots</span>: Robot painting is equal, uniform with high quality and precision. It can reach very difficult places due to their high degree of flexibility which can be difficult for humans, but can be achieved easily by robots.  A human needs to carry heavy painting gun and wear a mask for protection against toxic chemicals. A robots repetition rate is high as it does not suffer from fatigue. Safety levels which can be achieved by using a robot are high by saving humans from the chemical toxics.
			</li>
			<li>
				<span class="underline">Medical robots</span>: The operation is more precise with fewer mistakes. Robot can open small incisions in the body and carry out major operations with minimal damage to the patient. Therefore recovery time for the patient is decreased. The equipment is more hygienic and safe.
			</li>
			<li>
				<span class="underline">Mobile robots (with legs or wheels)</span>: for chemical power plant, under see or remote areas and bombs fields.  The advantage in leg robot is that it can avoid step over obstacles which can be dangerous like bomb or even to protect objects from being destroyed due to robot moving over them.
			</li>
			<li>
				<span class="underline">Robotics aircrafts and boats</span>: without a pilot which are guided from a station on the ground, which are used by army or rescue mission.
			</li>
		</ol>
		<h3>How are robots programmed?</h3>
		Industrial robot is programmed by moving objects from position 1 to position 5 by moving joints vertically or horizontally to pick up and place an object through the following steps:<br>
		Define points from P1 to P5:
		<ol>
			<li>Safely move above work piece (defined as P1)</li>
			<li>10 cm above work piece (defined as P2)</li>
			<li>At position to take work piece from conveyer (defined as P3)</li>
			<li>10 cm above conveyer with low speed (defined as P4)</li>
			<li>At position to leave work piece (defined as P5)</li>
		</ol>
		<br>
		Define program:
		<br>
		<ol>
			<li>Move to P1</li>
			<li>Move to P2</li>
			<li>Move to P3</li>
			<li>Close gripper</li>
			<li>Move to P2</li>
			<li>Move to P4</li>
			<li>Move to P5</li>
			<li>Open gripper</li>
			<li>Move to P4</li>
			<li>Move to P1 and finish</li>
		</ol>
		<h3>Control Architecture of a Robot</h3>
		<ol>
			<li>
				<span class="underline">Manipulator or rover</span>: Main body of Robot (Links, joints, other structural elements of the system)
			</li>
			<li>
				<span class="underline">End effector</span>: the part that is connected to the last joint hand
			</li>
			<li>
				<span class="underline">Actuators</span>: Muscles of the manipulators (Servo motors, stepper motors, pneumatic and hydraulic cylinder ..etc)
			</li>
			<li>
				<span class="underline">Sensors</span>: To collect the information about the internal state of robot or to communicate to the outside environment. For example: vision system, touch and tactile sensors etc which help to communicate with the environment.
			</li>
			<li>
				<span class="underline">Controller</span>: The controller receives data from the computer, controls the motions of the actuator and coordinates these motions with the sensory feedback information.
			</li>
		</ol>
	</body>
</html>
